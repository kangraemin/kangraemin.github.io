---
title: 운영체제 스터디 (1) - 운영체제 역사 및 개요
date: 2020-09-12
categories:
 - Operation System
tags:
 - OS
 - Computer structure
 - Computer science
---

> 운영체제 스터디 도중 [`쉽게 배우는 운영체제`](http://www.yes24.com/Product/Goods/62054527)를 읽고 요약한 내용입니다. 자세한 내용은 책을 구매하여 확인 부탁드립니다. 

<!-- more -->

# 1. 운영체제의 개요

## 운영체제 소개

임베디드 운영체제

- CPU의 성능이 낮고 메모리 크기도 작은 시스템에 내장하도록 만든 운영체제
- MP3플레이어, 네비게이션, PMP등에 삽입 됨
- CPU의 성능이 낮고 메모리의 크기가 작은 기계에 설치되기 때문에 일반 운영체제와는 약간 다름 ( 조금씩 빠져있음 )
- 임베디드 운영체제가 있으면, 지속적으로 기기에 추가적인 기능 삽입 가능

애니악

- 최초의 컴퓨터
- 크기에비해 성능이 매우 낮아 지금의 공학용 전자계산기 수준
- 미사일 탄도 계산이 목적
- 프로그래밍이 가능핬기 때문에 컴퓨터라 불림
- 진공관과 진공관을 연결시킴으로써 프로그래밍 수행

운영체제의 역할 → 컴퓨터 자원의 통치자 역할 

1. 성능 업그레이드 가능 
    - 운영체제가 없으면, 처음 구현 할 당시에 기능만 사용 가능 → 추가적인 기능 추가 불가
    - 운영체제가 있는 기계 → 기능의 추가나 성능의 변경이 가능하므로 Programmable 한 기계로 불림 ( 스마트폰 / 유선전화기를 생각해보라 )
2. 자원 관리에 중요한 역할 
    - 컴퓨터라는 정해진 자원을 여러 응용프로그램들이 나눠서 자원을 사용해야한다. 이 떄 효율적으로 자원을 관리해주는 역할을 수행한다.
    - 자원을 관리하는 강력한 중재자
        - 어떤 사용자가, 정보를 하드디스크에 저장하는 상황을 상정해보자. 사용자는 하드디스크의 특정 위치에 데이터를 저장 할 수 없다. 사용자는 운영체제에 어떤 정보를 저장 해 달라고 부탁하며, 운영체제가 알아서 적당한 위치에 저장해준다.
        - 이렇게 사용자가 직접 접근하는것을 막음으로써 악의적인 사용자가 데이터를 지우거나 덮어쓰는 일을 방지한다.
        - 그렇다면 사용자는 어떻게 컴퓨터의 자원을 이용할 수 있나 ?
            - 앞의 예처럼 저장을 생각해보자.
                1. 사용자가 저장하려는 데이터를 운영체제에게 줌 
                2. 운영체제는 번호표를 사용자에게 줌 
                3. 사용자는 번호표를 이용하여 데이터를 꺼내거나, 수정 할 수 있음 
            - 이와같이 사용자가 컴퓨터를 사용할 수 있도록 해주고 그 결과를 알려주는 것을 **인터페이스** 라고 함

 펌웨어 

- 운영체제는 소프트웨어
- 컴퓨터에 있는 하드웨어를 조정하고 관리하기위해 존재
- 따라서 하드웨어의 도움 없이 작동하기 어려움
- 운영체제 = 소프트웨어 + 하드웨어 = 펌웨어

운영체제의 역할

1. 자원 관리 ( 효율성 )
    - 컴퓨터 자원을 응용프로그램에 나누어 주어 사용자가 원활하게 작업할 수 있도록 도움
    - 응용프로그램이 여러개라면, 적당한 순서로 자원을 배분하고, 적절한 시점에 자원을 회수하여 분배
    - 적은 자원을 사용하여 결과를빨리 보여주어야 함
    - 운영체제 자체의 크기 최소화 및 코드 최적화 작업 필수
2. 자원 보호 ( 안정성 )
    - 악의적인 사용자나 미숙한 사용자로부터 자원을 보호
    - 운영체제의 작업이 불안정 ( ex_ 갑자기 컴퓨터가 꺼진다던지 ) 하면 유저 경험 좋지 못함
    - 하드웨어적인 보안 문제 해결 할 수 있어야 함
3. 하드웨어 인터페이스 제공 ( 확장성 ) 
    - 하드웨어 인터페이스 : 사용자가 다양한 부품을 편리하게 사용 할 수 있도록 해줌
    - 마우스 / 키보드 등의 제품을 연결 시 별도의 소프트웨어 설치 없이 사용 할 수 있도록 해줌 → 하드웨어 인터페이스
    - 드라이버
        - 운영체제가 하드웨어 인터페이스 지원을 할 수 있도록 해주는 프로그램.
        - 하드웨어 장치와 운영체제가 상호작용 하기 위해 만들어진 프로그램
    - 대게는 운영체제가 하드웨어 인터페이스를 자동으로 설치 해 주지만, 별도의 소프트웨어 설치가 필요한 것 도 있음
    - 플러그 & 플레이 기능 제공
4. 사용자 인터페이스 제공 ( 편리성 )
    - 사용자 인터페이스 : 사용자가 운영체제를 편리하게 사용하도록 지원하기 위한 것
    - MS DOS 때는 마우스 없이 키보드로만 작업
    - 키보드 + 마우스 등을 지원하며, 스마트폰에서는 터치 패드 지원
    - 운영체제를 편리하게 사용 할 수 있도록 제공되는 기능
    - 효율성과 함께 고려하라

## 운영체제의 역사

1. 최초의 컴퓨터
    - 애니악
    - 전선 / 회로로 구성된 컴퓨터
    - 진공관이 켜지면 1 꺼지면 0 → 2진법을 사용하는 계기
    - 운영체제 / 주변장치가 없었음
    - 다른 계산 / 수식 이용하려면 다시 연결해야함
2. 일괄 작업 시스템 
    - IC칩 탄생 ( 논리회로를 아주 작은크기로 구현 해 놓은것 )
    - 출력장치 없었음
    - 천공카드리더 / 라인프린터 사용
    - 천공카드 리더를 교체하면 다른 프로그램 바로 사용 가능
    - 한번에 한가지의 작업만 가능
    - 프로그램 실행 중간에 사용자가 데이터를 입력 / 수정하는것 불가능 → 일괄 작업 시스템
    - bat 파일 → batch job을 의미, autoexec.bat 은 운영체제가 시작 할 때 한꺼번에 처리해야할 작업들을 모아놓은 것
3. 대화형 시스템 
    - 키보드 / 모니터 등장
    - 사용자가 작업 중간에 값을 입력하거나, 중간 결과값을 보여줄 수 있게됨
    - 컴퓨터와 사용자의 대화와 같아서 대화형 시스템
    - 작업 시간을 예측하기 힘들다는 단점 ( 중간에 유저가 언제 낄지 모르니 )
4. 시분할 시스템 
    1. 시분할 시스템 
        - 다중 프로그래밍
            - 하나의 CPU로 여러 작업을 동시에 실행하는 기술
            - 하나의 CPU안에서 시간을 잘게 분할해 작업을 함으로써 다중 프로그래밍이 되는 것 처럼 구현
            - 이러한 시간 분배가 매우 빠른 속도로 반복되면 동시에 작업되는 것 처럼 보임
            - 이러한 시스템을 시분할 시스템이라고 통칭
            - 오늘날의 컴퓨터에는 대부분 시분할 시스템이 사용
            - 여러 작업을 동시에 처리하기 위한 추가적인 작업이 필요하다는 단점 존재
            - 또 중요한 작업이 일정 시간안에 끝나는 것을 보장하지 못하는 문제 발생
                - 시분할 시스템을 사용하지 않고 특정 시스템에서 일정 시간 앙네 작업이 처리되도록 보장하는 실시간 시스템 사용하는 경우도 있음
                    - 경성 실시간 시스템 : 지정한 응답 시간을 정확히 지키는 시스템 → 원자력 발전소의 온도제어 / 미사일 요격 등의 작업에 이용
                    - 연성 실시간 시스템 : 지정한 응답시간을 최대한 지키려고 노력하지만 어느정도 융퉁성이 허용된 시스템 → 동영상 재생기는 응답 시간안에 작업이 처리되어야 끊김 현상이 없지만, 치명적이진 않음
    2. 다중 사용자 시스템
        - 동시에 실행되는 작업의 갯수 → 멀티프로그래밍 수준
        - 하나의 컴퓨터에서 여러명이 작업하거나, 한명이 여러 프로그램을 동시에 사용 할 수 있는 환경이 조성 된 것
5. 분산 시스템
    - 최초의 개인용 컴퓨터 애플 2 발표
    - 여러 운영체제 나옴 ( MS-DOS ... )
    - 인터넷 탄생 ( 이때 TCP / IP 를 비롯한 여러 프로토콜 제작 )
    - 하나의 커다란 컴퓨터를 사용하는 메인 프레임 시대에서, 작은 컴퓨터들을 하나로 묶어 대형 컴퓨터에 버금가는 시스템을 만듦 → 분산 시스템
    - 분산되어있는 여러 컴퓨터로 작업을 처리하고 그 결과를 상호 교환하도록 구성한 시스템
6. 클라이언트 / 서버 시스템 
    - 분산 시스템에선 각 컴퓨터들이 동등한 지위라서, 컴퓨터가 고장날 시 많은 문제점이 존재 ( 교체, 분배의 문제 )
    - 작업을 요청하는 클라이언트와, 작업을 진행하는 서버컴퓨터로 분리
    - 대부분의 웹 시스템에서 사용
    - 서버 과부화 문제 다수
    - 데몬
        - 멈추지 않고 계속 작동하는 프로그램을 지칭
        - 데몬을 가진 컴퓨터를 서버 컴퓨터로 지칭
        - 웹 데몬이 설치된 컴퓨터 → 웹서버, FTP 데몬이 설치된 컴퓨터 → FTP 서버 ...
7. P2P시스템 
    - 서버를 거치지 않고 사용자와 사용자를 직접 연결
    - 서버에서는 파일 검색만 하고, 사용자간에 파일 전송이 이루어지기 때문에 서버 부하 적음
    - 메신저에도 P2P 시스템이 이용됨
        - 서버에서 사용자 인증, 출석( 친구나 관련자가 현재 어디에 있는지, 어떤 상태인지 확인 해주는 작업 )등의 절차만 거친 뒤 사용자간에 채팅 / 데이터 전송 하도록 구현 시 서버 부하 적음
    - 대용량 파일 공유
        - 유저와 유저가 파일을 주고 받을때, 주는 쪽 유저의 네트워크가 종료되면 파일 전송이 실패하게 됨
        - 다시 시도할 때 처음부터 다시 받아야하는 문제 발생
        - 파일을 n개로 쪼개고, n명이 각 하나씩 보내주면 한사람이 끊기더라도 다운로드 재진행이 쉬워짐
    - 서버가 있는 P2P / 서버가 없는 P2P
        - 서버가 있는 P2P는 일반적인 P2P 웹사이트를 생각해보면 쉬움
        - 서버가 없는 P2P의 예로 블록체인 기술이 있음
8. 기타 컴퓨터 환경 
    1. 그리드 컴퓨팅
        - 필요한 컴퓨팅 자원을 구매하여 사용하는 컴퓨팅 환경을 지칭
        - 분산 시스템의 한 분야, 서로 다른 기종의 컴퓨터를 묶어 대용량의 컴퓨터 풀을 구성하고, 이를 원격지와 연결하여 대용량 연산을 수행하는 컴퓨팅 환경
        - 그리드 딜리버리
            - 어떤 파일을 유저가 웹하드에서 다운로드 받으려 할 때, 서버에서 주는것이 아니라 전에 해당 파일을 내려받은 컴퓨터로 부터 몰래 데이터를 빼와서 전달하는 경우가 그리드 딜리버리
            - 개인 컴퓨터 자원을 소모하며 서버 컴퓨터 자원 아낌
        - 하드웨어적인 컴퓨팅 환경의 통합
    2. SaaS
        - 사용자가 필요할 때 소프트웨어 기능을 이용하고, 그만큼만 비용을 지불하는 개념
        - 프로그램 설치 필요없고 인터넷에만 연결되면 사용 가능
    3. 클라우드 컴퓨팅
        - 어디서나 응용 프로그램과 데이터를 자유롭게 사용 할 수 있는 컴퓨팅 환경 ( 그리드 컴퓨팅 + SaaS )
        - IDC와 반대되는 개념
        - ex) 스마트폰 데이터 클라우드 백업
    4. 사물인터넷 
        - 사물에 센서와 통신 기능을 내장하여 인터넷에 연결하는 기술
        - 사물들이 데이터를 주고받아 스스로 분석 / 학습 후 서비스 제공

## 운영체제의 구조

1. 커널과 인터페이스
    - 프로세스 관리 / 메모리 관리 / 저장장치 관리 등 운영체제의 핵심적인 기능을 모아놓은 것, 자동차의 엔진에 해당 됨 → 운영체제의 성능은 커널이 좌우한다.
    - 스마트폰의 운영체제에도 커널이 존재 ( AOS / IOS 모두 유닉스 기반, AOS는 커널이 공개되어 있지만, IOS는 비공개 )
    - 커널에 사용자의 명령을 전달해주고, 커널의 실행 결과를 사용자에게 알려주는 역할을 해주는 것이 인터페이스
    - 운영체제는 이러한 인터페이스와 커널로 구성되어 있고, 운영체제속 이 두가지 ( 인터페이스 / 커널 )를 분리 할 수도 있다.
    - 운영체제속 인터페이스와 커널을 분리하여 같은 커널을 사용하더라도 다른 인터페이스를 갖게 할 수 있다.
        - macOS도 Unix기반의 커널을 사용하고, 자체적인 인터페이스를 구축 한 OS이다.
        - 같은 Unix기반의 커널을 shell 인터페이스로 사용 가능 하지만, 일반 유저의 사용성이 떨어 지는 단점이 있다.
2. 시스템 호출과 디바이스 드라이버 
    1. 시스템 호출 
        - 시스템 호출은 커널이 자신을 보호하기 위해 만든 인터페이스
        - 사용자 / 응용프로그램이 자원에 직접 접근하는 것을 차단하고, 자원을 이용하려면 시스템 호출이라는 인터페이스를 이용하여 접근 하게 강제함
        - 유저가 카페에 가서 커피를 직접 타먹는것 / 종업원에게 커피를 주문하는것의 비유를 기억
            - 직접 타먹는것이 자신에게 더 알맞은 커피를 타먹을 수 있을진 모르지만, 커피머신이 망가 질 수 있으며 원하는 값이 안나올 수 있음
            - 종업원에게 커피를 주문하고, 결과값만 받으면 커피머신을 보호할 수 있음 ( 잘 교육된 종업원, 버그가 없는 OS일 경우 )
            - 시스템 호출이 카페에서 종업원의 역할이 하는 역할에 대응됨
        - 응용프로그램의 예
            - 14라는 위치에 21이라는 값을 하드웨어에 직접 저장시, 14라는 위치가 다른 응용 프로그램에서 사용중이거나, 중요한 위치일 수 있기떄문에 안정성 저하
            - 따라서 `write()` / `read()` 함수 따위를 이용하여 하드웨어에 접근하여 안정성 향상
        - 시스템 호출은 커널이 제공하는 시스템 관련 서비스를 모아놓은 것
        - 시스템 호출은 커널이 제공하는 시스템 자원의 사용과 연관된 함수
        - 하드웨어 자원에 접근하거나, 운영체제가 제공하는 서비스를 이용하려 할 때엔 시스템 호출을 사용해야 함
    2. 드라이버 
        - 커널과 하드웨어의 인터페이스
        - 컴퓨터 하드웨어의 종류가 아주 많은데, 하드웨어에 맞는 프로그램들을 커널이 모두 가지고 있을 수는 없음
        - 하드웨어 제작자가 관련 소프트웨어를 만드는 것이 유리
        - 커널은 기본적인 입출력 부분의 드라이버를 보유 하고 있고, 하드웨어의 특성을 반영한 소프트웨어를 하드웨어 제작자에게 받아 커널이 실행될 때 함께 실행되도록 함
        - 하드웨어 제작자가 만든 소프트웨어를 디바이스 드라이버로 지칭
        - 마우스, 키보드와 같이 간단한 드라이버는 커널에 포함되어 있지만, 그래픽카드, 프린터와 같은 디바이스 드라이버는 사용자가 직접 설치해야하는 경우가 더 많음
    - 사용자 / 응용프로그램은 시스템 호출을 거치지 않고 커널에 접근 할 수 없고, 하드웨어는 드라이버 ( 커널에 포함된 드라이버 or 하드웨어 제작자가 직접 제작한 드라이버 )를 통해서만 커널에 접근 할 수 있다.
3. 커널의 구성
    - 커널은 주로 프로세스 관리 / 메모리 관리 / 파일 시스템 관리 / 입출력 관리 / 프로세스 간 통신 관리 등의 작업을 하며, 이러한 작업들을 어떻게 구현했는지에 따라 구분된다.
    1. 단일형 구조 커널 
        - 커널의 핵심 기능을 구현한 모듈들이 구분 없이 하나로 구성되어 있음
        - 초기의 유닉스 운영체제가 이에 해당
        - 모듈간의 통신 비용이 없어 빠름
        - 유지보수가 **매우** 힘듬
        - 요즘엔 운영체제가 커짐에 따라 구현 불가능
    2. 계층형 구조 커널 
        - 비슷한 기능을 가진 모듈을 묶어서 하나의 계층으로 만들고, 계층간의 통신을 통해 운영체제를 구현하는 방식
        - 오류 발생시 해당 계층만 따로 수정하면 되기 때문에 유지보수 용이
    3. 마이크로 구조 커널 
        - 계층형 구조 커널에서는 사용자의 니즈에 맞춰 계속해서 기능을 추가함
        - 따라서 커널의 크기가 계속 커지고 방대해짐
        - 이러한 문제를 해결하기위해 커널 내부에서는 가장 기본적인 기능만 제공
        - 많은 부분을 사용자 영역에 구현 해놓음
        - 커널에서는 메모리 관리 / 프로세스간의 동기화 서비스를 제공하며, 메모리 관리자와 동기화 모듈은 프로세스간 통신 모듈로 연결
        - 나머지 작업은 사용자 영역에 구현 되어 있음
    4. 가상 머신 
        - C언어에는 낮은 호환성의 문제가 있음
            - 유닉스에서 만든 C코드가 윈도우에서 동작이 안되기 떄문에 따로 수정해주어야 함
        - 이러한 문제를 해결해준 언어가 Java
            - 운영체제 위에 가상머신을 만들고 그 위에서 응용 프로그램이 작동하게 하는것
        - 가상머신 → 운영체제와 응용프로그램 사이에 작동하는 프로그램
        - 가상머신을 활용하면 응용프로그램이 모두 돋일한 환경에서 작동하는것 처럼 보임
        - 자바는 유닉스 / 윈도우에서 작동하는 다양한 가상머신을 만들어 배포하는데 이것이 JVM

    API / SDK ?

    1. API ( Application Programming Interface ) 
        - 응용 프로그램이 자신과 연관된 프로그램을 만들 수 있도록 제공하는 인터페이스
        - 포토샵의 필터를 개발하려는 사람들을 위해 프로그래밍 인터페이스를 제공→ 포토샵의 API
        - 시스템 호출은 운영체제의 API라 볼 수 있음

    2. SDK ( System developer's Kit )
        - 프로그램 개발자를 위해 API 및 API사용 메뉴얼 뿐 아니라 개발에 필요한 코드 편집기, 에뮬레이터 등 개발용 응용프로그램까지 하나로 묶어서 배포하는 개발 툴
        - 개발자를 위한 종합 선물 셋트, Android Studio가 이에 해당