---
title: 운영체제 스터디 (12) - 파일 시스템
date: 2021-03-14
categories:
 - Operation System
tags:
 - OS
 - Computer structure
 - Computer science
---

> 운영체제 스터디 도중 [쉽게 배우는 운영체제](http://www.yes24.com/Product/Goods/62054527)를 읽고 요약한 내용입니다. 자세한 내용은 책을 구매하여 확인 부탁드립니다. 

<!-- more -->

# 11. 파일 시스템

## 파일과 파일 시스템

### 파일 시스템의 개요

- 파일 시스템
    - 대신 파일을 보관하고, 관리하는 파일 관리자를 두어 저장장치의 전체 관리를 하는 시스템
    - 사용자가 직접 저장장치 내부를 조작 한다면, 문제가 있을 수 있음
    - 파일 관리자
        - 사용자가 직접 파일을 보관하거나, 접근하지 못하도록 하고, 대신 해주는 역할
        - 가상 메모리에서, 메모리 매핑 테이블을 사용하여 가상 주소를 물리 주소로 변환해주는 것과 같이, 파일 관리자가 파일 테이블을 사용하여 파일을 관리
        - 파일 테이블을 활용하여, 파일의 생성 / 수정 / 삭제 등을 수행
        - 파일을 사용 하고자 할 때, 읽기 / 쓰기 / 실행 등 다양한 접근 방법 제공
    - 파일 디스크립터
        - 사용자가 특정 파일에 접근 하기 위한 파일 관리자로부터 받은 권한
- 파일 시스템의 기능
    - OS마다 파일 테이블을 가지고 있음
    - Window → FAT / NTFS, Unix → I-node
    - 사용자가 파일을 생성하고, 파일을 편리하게 관리할 수 있도록 디렉터리 구조를 제공
    - 파일 구분 위해 파일 이름, 확장자를 만들어 관리
    - 파일 구성
        - 파일 / 디렉터리를 생성
    - 파일 관리
        - 파일 수정 / 삭제 등의 관리를 하고, 수시로 조각 모음을 하여 속도 향상
    - 접근 권한 관리
        - 다른 사용자로부터 파일을 보호하기 위해 접근 권한 관리
    - 접근 방법 제공
        - 파일 읽기 / 쓰기 / 실행 할 수 있도록 접근 방법 제공
    - 무결성 보장
        - 파일 내용이 손상되지 않도록 무결성 보장
    - 백업과 복구
        - 사고로 부터 파일을 보호하기 위해 백업 / 복구 작업
    - 암호화
        - 파일을 암호화 하여 악의적인 접근으로 부터 파일 보호
- 블록과 파일 테이블
    - 데이터는 운영체제와 저장 장치 간에 블록 단위로 전송 됨
    - 블록 하나에 주소 하나가 할당 됨
    - 섹터 마다 주소 부여시 메모리에 다 넣을수 없기 때문
    - OS에서 사용할 블록 크기를 설정 할 수 있는데, 너무 작게 설정하면 단편화 현상이 줄어들지만, 입출력 속도가 늦어짐
    - 크기가 큰 파일을 많이 저장하는 경우, 블록 크기를 크게 잡는것이 좋음
- 파일 분류와 확장자
    - 파일 → 논리적인 데이터의 집합
    - 실행 파일
        - 운영체제가 메모리로 가져와 CPU를 이용하여 작업을 하는 파일
        - 사용자의 요청으로 프로세스가 된 파일
    - 데이터 파일
        - 실행파일이 작업하는데 필요한 데이터를 모아놓은 파일
        - 사진 / 음악 / 문서파일 등
        - 스스로 프로세스가 될 수 없음
        - 데이터 파일을 실행하면, 데이터파일에 맞는 실행 파일을 OS가 실행 시켜 주기 때문에, 사용자는 데이터 파일을 실행 했을 때 실행 되는 것 처럼 인지 하는 것
    - 파일을 구분하기 위해, 파일에는 헤더가 달려 있음
    - 모든 종류의 파일은 각각 고유한 헤더를 가지고 있음
    - 모든 파일에 이름에는 확장자가 붙는데, 파일에 확장자를 붙이면 파일의 성격을 알 수 있음
- 파일 이름과 연결 프로그램
    - 대부분은, 파일 이름이 `파일 이름.확장자` 로 구성 됨
    - 초창기엔 확장자명의 길이가 3글자로 제한되었지만, 최근엔 아님 ( 3글자가 규칙처럼 굳어 졌을 뿐 )
    - 마침표 여러개 일시, 마지막 마침표의 뒤가 확장자로 인식 됨
    - 파일 이름에 `*` / `?` 를 넣을 수 없는 경우가 많은데, 이는 파일을 검색 할 떄 사용되는 특수 기호이기 때문이다
    - 파일을 더블 클릭하면, 파일에 연결된 응용 프로그램이 실행 됨
    - 데이터 파일을 더블 클릭하면 연결된 응용 프로그램이 실행 되는것
    - 확장자를 바꾼다고 해서 파일 내용이 바뀌지는 않음
- 파일 속성
    - 파일의 고유한 속성들이 파일 헤더에 기록 됨
    - 이름 / 타입 / 크기 / 접근 권한 등이 기록 됨
    - 파일 헤더
        - 파일 테이블에서 관리하며, 파일의 이름, 종류, 크기 등 일반적인 내용이 담김
        - 저장장치의 몇번쨰 블록에 있는지도 담겨 있음
    - 고유 헤더
        - 응용프로그램이 필요로 하는 고유 헤더가 따로 달려 있음
        - 파일의 버전 번호, 특수 정보 등 응용 프로그램이 필요로 하는 정보가 담겨 있음
        - 파일을 복구할 때 유용하게 사용 됨
            - 빠른 포맷 / 휴지통에서 삭제 시, 실제 데이터가 삭제되는것이 아니라 파일 테이블이 삭제 되거나, 파일 테이블에 있던 파일 헤더가 사라짐
            - 이때, 데이터 파일의 고유 헤더는 저장 장치에 남아 있음
            - 따라서, 파일 복구 프로그램이 모든 블록을 찾아다니면서 고유 헤더에 있는 정보를 이용하여 파일을 원래 상태로 복원 할 수 있음

### 파일 구조

- 파일을 어떻게 구성하느냐에 대한 구조
- 순차 파일 구조
    - 카세트 테이프 처럼, 파일 내용이 하나의 긴 줄로 늘어선 형태
    - 파일을 작업 할 때, 앞에서 부터 뒤까지 순차적인 접근만 가능
    - 사용자가 파일 작업을 하려면, open() / create() 명령을 사용하여 운영체제로 부터 권한 ( 파일 디스크립터 )를 얻어야 함
    - 순차적인 접근 방식에서는, 파일 디스크립터가 앞에서 부터 뒤로 계속 전진하며, 작업을 하다가 특정 위치로 파일 디스크립터를 옮겨야 할때는 beek() 명령어를 사용하여 뒤로 전진
    - 장점
        - 순서대로 기록 되기 때문에, 저장 공간에 낭비되는 부분이 없고 구조가 단순
        - 순서대로 데이터를 읽거나 저장 할 때, 속도가 빠름
    - 단점
        - 새로운 데이터를 삽입하거나, 삭제할 때 시간이 많이 걸림 ( 옆으로 밀고 삽입 / 삭제 후 빈공간 매꿈 )
        - 특정 데이터로 직접 접근이 어렵다
- 인덱스 파일 구조
    - 음악 CD 처럼, 순차 파일 구조에 인덱스 테이블을 추가 하여 순차 접근 / 직접 접근이 가능 한 형태
    - 음악 CD는 처음부터 끝까지 순차적으로 재생 할 수도, 특정 곡으로 바로 이동 할 수도 있음
    - 이러한 방식을 인덱스 순차 접근 이라고 함
    - 인덱스 테이블에는, 파일의 인덱스와, 파일이 존재하고 있는 블록이 기입되어 있음
    - 특정 인덱스로 접근 시, 해당 파일이 존재하고있는 블록에 직접 접근을 할 수 있도록 해 줌
    - 현대의 파일 시스템에서 많이 사용 됨
    - 인덱스 파일 테이블을 여러개 만들어 다양한 접근이 가능 하기도 함 ( 재생 목록을 여러개 ㅏ만들 듯 )
- 직접 파일 구조
    - 데이터의 특정 값에 어떤 관계를 정의하여 물리적인 주소로 바로 변환하는 파일 구조
    - 해시 테이블을 생각하면 좋음
    - 해시 함수 → 직접 파일 구조에서, 데이터와 주소에 대한 관계를 지정 해주는 함수
    - 데이터 접근이 매우 빠름
    - 해시 함수의 선정이 매우 중요

## 디렉터리의 구조

- 디렉터리의 개념
    - 여러 파일을 섞어놓은 것 보다, 비슷한 파일 끼리 모아서 보관하면 원하는 파일을 찾기도 쉽고 관리하기도 편함
    - 디렉터리는, 관련 있는 파일을 하나로 모아놓은 파일
    - 루트 디렉터리는 `/` 로 표기
    - 디렉터리도 하나의 파일이며, 일반 파일에는 데이터가 담겨 있으나, 디렉터리에는 파일정보가 담겨 있음
    - 파일과 마찬가지로 헤더를 가지며, 디렉터리의 이름, 만든 시간, 권한 등의 정보가 담겨 있음
    - 마침표 하나는, 자기 자신의 디렉터리 이며, 마침표 두개는 상위 디렉터리를 가리킴
- 경로
    - 파일이 전체 디렉터리 중 어디에 있는지를 나타내는 정보
    - 서로 다른 디렉터리에는 이름이 같은 파일 존재 가능하나, 경로가 같은 곳에는 이름이 같은 파일이 존재 할 수는 없음
    - 절대 경로
        - 루트 디렉터리를 기준으로 파일의 위치를 나타내는 방식
        - 루트 디렉터리에서 시작하는 절대적인 위치를 나타 냄
        - `/program/data/example` 의 형태로 표기 할 수 있음
    - 상대 경로
        - 현재 있는 위치를 기준으로 파일의 위치를 나타내는 방식
        - `../user/examplefile` 의 형태로 표기 할 수 있음
    - `cd` 명령어를 통해 디렉터리 이동 가능한데, 절대 경로 상대 경로 둘 다 사용 가능
- 디렉터리 구조
    - 다단계 디렉터리 구조
        - 디렉터리속에 디렉터리가 존재 할 수 있는 구조
        - 루트 디렉터리를 기준으로, 가지처럼 있어 트리 디렉터리 구조라고도 함
        - 자료 구조 상으로 트리는, 순환이 없는 그래프 형태
        - 하지만 현재 파일 시스템에서 다단계 디렉터리 구조는 링크 ( 바로가기 ) 떄문에 순환이 생길 수 있는 시스템
        - 따라서 디렉터리 구조는 트리가 아닌 그래프 구조
- 마운트
    - 여러개의 파티션, 디스크를 통합하는 명령어
    - 윈도우의 초기 개발 시에는, 파일 시스템의 최대 디스크 크기가 32GB 였음
    - 그래서, 최대 디스크 크기를 넘는 경우 파티션으로 분리하고, 각 파티션마다 파일 시스템을 구축 해야 했음
    - 유닉스의 경우 파일 테이블의 크기에 제한이 없음
    - 유닉스의 경우 하나의 파일 테이블로 여러개의 디스크, 파티션을 통합하여 관리 할 수 있음
    - USB / CD와 같은 외부 저장 장치도, 마운트로 파티션에 붙이고 마운트 해제를 통해 분리 할 수있음

## 디스크 파일 할당

### 연속 할당, 불연속 할당

- 파일 시스템은, 전체 디스크 공간을 같은 크기로 나누고 각 공간에 주소를 붙여서 관리함
- 나뉜 공간 하나가 블록
- 블록 주소를 가진 파일 테이블을 관리
- 파일 테이블은 파티션당 하나가 존재하며, 파티션의 맨 앞에 존재함
- 연속 할당
    - 파일을 구성하는 데이터를 디스크 상에 연속적으로 배열 하는 방식
    - 실제로는 사용되지 않음 ( 물리메모리의 가변 분할 방식을 생각하면 비슷하나, 메모리와 저장장치는 용도와 쓰임새가 다르기 때문 )
- 불연속 할당
    - 비어있는 블록에 데이터를 분산하여 저장하고, 이 정보를 파일 시스템이 관리하는 방식
    - 실제로 많이 쓰임
    - 연결 할당
        - 파일에 속한 데이터를 Linked List로 관리하는 방식
        - 파일 테이블에는 시작 블록에 대한 정보만 저장하고, 시작 블록 부터 다음에 저장된 블록의 주소를 연결 하여 데이터를 가져옴
        - 테이블 형태로 관리하는데, 윈도우의 FAT 방식이 이에 해당
        - FAT
            - 파티션 전체 블록에 대한 정보를 가진 테이블이며, 행의 개수가 그 파티션에 존재하는 블록의 개수와 동일
            - 파일 테이블에는 파일의 정보와 함께, 파일의 시작 블록 정보를 갖고 있음
            - FAT에는, 해당 블록 다음에 연결된 블록에 대한 주소 정보가 저장 되어 있음
            - 따라서 파일 테이블에서 시작 주소 정보를 기반으로 FAT에서 연결된 블록을 쫒아가면, 해당 데이터를 모두 가져 올 수 있음
            - 종류로 FAT 12 / 16 / 32 가 있는데, 각 숫자는 파일 할당 주소의 최대 크기를 나타 냄
            - 따라서, 하나의 파티션이 사용 할 수 있는 디스크 용량이 테이블 주소 크기로 제한 됨
            - 또, FAT 32인 경우 8TB까지 지원하지만, 파일 하나의 크기가 4GB로 한정 됨
            - 따라서, FAT 32로 포매팅된 저장 장치에, 4GB 이상의 파일을 저장하기 위해서는 NTFS 파일 시스템으로 변경 해 주어야 함
        - 인덱스 할당
            - FAT의 최대 할당 크기에 제한이 있다는 단점을 해결하기 위한 방식
            - 테이블의 블록 포인터가 데이터 블록을 연결하는 것이 아니라, 데이터의 인덱스를 담고 있는 인덱스 블록을 연결
            - 인덱스 블록은 실제 데이터의 위치에 대한 정보를 순서대로 보관하고 있음
            - 인덱스 블록이 꽉 차면, 인덱스블록을 연결하는 간접 인덱스 블록을 만들어 무한히 확장 할 수 있음
            - 위와 같은 파일 시스템으로 유닉스의 I-node가 있음
            - I-node table
                - 아래의 항목으로 구성 됨
                - 파일 제어 블록
                    - 파일 소유자와, 각종 속성을 나타내는 블록
                    - 파일에 대한 모든 권한의 정보를 포함 하고 있음
                    - 슈퍼블록이라고도 칭함
                - 블록 포인터
                    - 데이터가 있는 블록의 위치를 직접 연결하는 포인터
                - 인덱스 블록
                    - 실제 데이터의 위치에 대한 정보를 순서대로 보관하고 있는 블록
                - 간접 포인터
                    - 크기가 작은 파일은, 데이터와 직접 연결된 블록 포인터로 빠르게 접근 할 수 있음
                    - 블록 포인터가 다 차면, 인덱스 블록을 생성 한 후 간접 포인터를 생성하여 인덱스 블록과 데이터를 연결하는 블록을 생성
                - 이중 / 삼중 간접 포인터
                    - 인덱스 블록 하나로 데이터를 다 연결할 수 없는 경우, 인덱브 블록을 연결하는 다중의 인덱스 블록을 생성하여 연결
                - 요약하면, 파일 크기가 작은 경우 블록을 직접 연결
                - 파일 크기가 큰 경우 인덱스 블록과 이를 연결하는 간접 포인터를 이용하여 확장

### 디스크의 빈 공간 관리

- 디스크 블록의 크기는 파일 시스템마다 유저가 정할 수 있음
- 디스크 블록의 크기를 크게 잡으면, 적은 주소로 많은 양의 데이터를 관리 할 수 있으나 낭비 되는 공간 ( 내부 단편화 )이 생김
- 디스크 블록의 크기를 작게 잡으면, 많은 주소라 적은 양의 데이터를 관리해야 해서 많은 양의 블록 포인터가 필요함
- 디스크에 파일을 저장 할 때 마다, 빈 공간을 찾는 것은 비효율적이기 때문에, 빈 블록의 정보만 모아놓은 빈 공간 리스트를 유지 하고 관리함
- 파일을 삭제 할 때는, 실제 데이터를 지우는 것 보다는 해당 파일이 있던 블록이 빈 공간 리스트에 더해지는 경우가 많다.
- 이때, 빈 공간 리스트에 등록 되면, 해당 블록은 빈 공간이라고 간주
- 따라서 해당 블록에 다시 데이터가 쓰이지 않으면, 데이터를 복구 할 수 있는 여지가 생김
- 갑작스럽게 컴퓨터가 종료 된 경우, 데이터를 저장 했으나 블록 포인터가 사라져서 데이터가 없어진 것 처럼 보일 수있음

### 유닉스 파일의 특징

- 유닉스 파일 시스템 에서는, 파일에 접근 할 수 있는 권한, 형태에 관해 기술된 접근 패턴이 존재
- X XXX XXX XXX 형태
- 첫번째 자리 ( X )는, 파일의 종류를 나타 냄 ( - : 일반 파일, d : 디렉터리, l : 링크 )
- 나머지 아홉개를 세개씩 묶은 덩어리 ( 한덩어리 : XXX )는 RWX ( Read, Write, Execute ) 권한을 나타냄
- 첫번째 덩어리는 파일의 소유자, 두번쨰 덩어리는 소유자가 속한 그룹, 세번째 덩어리는 소유자도 아니고 같은 그룹도 아닌 제3자의 권한을 나타 냄
- Read → 100 / Write → 010 / Execute → 001 의 형태로 나타 냄
- 덩어리의 권한이 10진법 7로 주어지면 이진수 111의 의미가 되므로 RWX 모두 가능한 형태
- chmode 777 이라고 하면, 세덩어리 모두 7의 권한을 주어 소유자, 그룹, 제3자 모두 RWX가 모두 가능한 상태
