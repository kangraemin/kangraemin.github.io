---
title: 운영체제 스터디 (3) - 프로세스와 쓰레드
date: 2020-10-12
categories:
 - Operation System
tags:
 - OS
 - Computer structure
 - Computer science
---

> 운영체제 스터디 도중 [쉽게 배우는 운영체제](http://www.yes24.com/Product/Goods/62054527)를 읽고 요약한 내용입니다. 자세한 내용은 책을 구매하여 확인 부탁드립니다. 

<!-- more -->

# 3. 프로세스와 스레드

## 프로세스의 개요

> 프로세스 vs 프로그램

![pic1.png](/assets/images/posts/2020-10-12-process-thread/pic1.png)

### 요리사 모형에 빗댄 프로세스의 여러 상태

- 업장의 주문서 에는 주문 순서를 알려주는 일련번호, 테이블번호, 어떤 요리인지 등 작업 해야할 것들에 대한 세부 정보가 담겨 져 있음   

### 1. 일괄 작업 방식

- 레스토랑에 하나의 테이블만 있는 것
- 손님이 식사를 마치고 나가야만 다른 손님을 받을 수 있음
- 작업 효율의 저하
- 손님에게 미리 주문을 받아 놓는다고 가정 시 미리 받은 주문에 대한 주문서를 Queue에 저장 함

### 2. 시분할 작업 방식

- 개선점
    - 일괄 작업 방식에서는 손님이 식사하는 동안 다른 손님의 요리를 만들 수 없었음, 하지만 시분할 작업 방식에서는 첫번째 손님이 식사하시는 동안 두번째 손님의 식사를만들어 제공 할 수 있음
    - 요리사는 한명이지만, 시간을 쪼개어 동시에 실행 하는 것 처럼 보이게 해줌
- 주문 처리 방식
    1. 여러 손님들에게 주문서를 미리 받음
    2. 주문 받은 주문서에 있는 여러 요리 중에 한가지를 만든 뒤, 다 만들어 지면 해당 주문서를 맨 뒤로 옮김
    3. 그 다음번 주문서를 가져와 요리를 시작
    4. 주문서에 있는 모든 요리가 제공 되면, 주문서를 삭제
- 주문서가 주문 목록에 올라 오는 것 → 요리의 시작을 의미
- 요리사가 요리 하는 동안, 주문서는 주문 목록에서 대기하거나, 요리사가 요리하는 상태를 왕복
- 주문 목록의 삭제 → 해당 요리는 종료 됨
- 대기 목록 / 보류 목록
    - 대기목록
        - 새우 튀김을 해야 하는데, 새우가 손질 되지 않은 상황을 가정
        - 효율적으로 일하기 위해 보조 요리사에게 새우를 손질하라고 지시 한 뒤 그 다음 요리 시작, 새우가 다 손질 되면 신호를 받음
        - 대기 목록은, 새우 손질이 끝날 때 까지 주문서 ( 작업 )가 기다리는 공간
        - 손질이 완료 되면, 진행하던 요리를 멈추는 것은 비효율 적이므로 대기 목록에 있던 작업을 주문 목록으로 이동하여 다음 순서를 기다림
    - 보류 목록
        - 언제 다시 시작될 지 모르는 주문서가 기다리는 공간
        - 보류 목록에 있던 주문서에 해당하는 손님이 음식을 달라고 하면, 보류 목록에 있는 주문서를 다시 주문 목록으로 보냄
        - 손님이 주문을 폐기하면, 주문서를 폐기
        - 언제 다시 시작될 지 모르거나, 중간에 그만 둘 지 모르는 작업들이 여기에 담김

### 프로그램에서 프로세스로의 전환

- 프로세스
    - 컴퓨터 시스템의 작업 단위, Task로도 불림
- 요리
    - 요리의 주문서에 해당하는 작업 지시서를 제작
    - 이 작업 지시서에는 주문 사항에 대한 상세 정보들이 담겨 져 있음
    - 주문서가 없으면 요리가 진행되지 못함
- 컴퓨터
    - 프로세스의 작업 지시서에 해당하는 프로세스 제어 블록을 제작
    - 프로세스 제어 블록에는 프로세스를 처리하는데 필요한 다양한 정보들이 담겨 져 있음
    - 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못함
    - 프로세스 구분자, 메모리 관련 정보, 각종 중간값 등이 들어 있음
        - 프로세스 ID
            - 메모리에는 여러개의 프로세스가 존재
            - 프로세스 ID는 각 프로세스를 구분하는 ID 값
        - 메모리 관련 정보
            - 실행하려는 프로세스의 메모리 위치에 대한 정보
            - 메모리 보호를 위한 경계 레지스터, 한계 레지스터도 담겨 져 있음
        - 각종 중간값
            - 어떤 요리까지 손님에게 제공 되었는지 주문서에 표기하는 것과 유사
            - 프로세스가 사용했던 중간 세이브 지점에 대한 데이터
    - 운영체제가 해당 프로세스를 관리하기 위해 만들어진 데이터 구조 이기 때문에, 운영체제 영역에 존재
    - 프로세스가 종료되면, 프로세스 제어 블록도 폐기

> 프로세스 = 프로그램 + 프로세스 제어 블록 ( 프로그램이 운영체제로 부터 프로세스 제어 블록을 얻은 상태 )

- 사용자가 실행 한 프로그램만 메모리에 올라 와 있는 것이 아님 ( 운영 체제도 프로그램, 부트스트랩 참조 )

### 프로세스의 상태

- 시분할 시스템에서는, 단품 요리를 번갈아 가며 요리를 하는 과정과 같기 때문에, 프로세스의 상태가 다양함
- 활성 상태
    - CPU 스케줄러
        - 준비 단계에 있는 여러 프로세스 중, 실행 상태에 갈 프로세스를 선정하는 작업은 CPU 스케줄러가 담당
        - 해당 CPU 스케줄러의 작업을 dispatch라고 명명
        - CPU 스케줄러는 프로세스의 전 상태를 관리   
    1. 생성 상태
        - 프로세스가 메모리에 올라 와 실행 준비를 완료 한 상태
        - 프로세스를 관리하는 데 필요한 프로세스 제어 블록을 운영체제로 부터 할당 받은 상태
    2. 준비 상태
        - 생성 된 프로세스가 CPU를 얻을 때 까지 기다리는 상태
        - CPU는, 한번에 한가지 일을 처리 할 수 있기 때문에 생성 상태에 있는 프로세스는 본인의 CPU 순서가 올 때 까지 대기해야 하는데, 이 상태를 준비 상태라고 명명
        - ready queue에 프로세스 제어 블록이 쌓여 져 있음
        - 준비 상태에 있는 프로세스를 실행 상태로 옮기는 작업을 Dispatch 명령으로 처리
    3. 실행 상태
        - 준비 상태에 있는 프로세스 중 한가지가 CPU를 얻어 실제 작업을 수행하는 상태
        - 일정 시간 동안 CPU를 사용 할 권리를 얻으며, 이 시간 동안 작업을 완료하지 못했다면 ( 프로세스 제어 블록에 남은 작업이 있다면 ) 프로세스를 다시 준비 상태로 옮김
        - 타임아웃
            - 위에서 말한 일정 시간을 타임 퀀텀, 타임 슬라이스 라고 칭함
            - 이 시간 동안 작업을 완료하지 못해 준비상태로 프로세스가 돌아가는 것을 타임아웃 이라고 칭함
            - CPU는 클록에 타임 슬라이스가 흐른 뒤 알려달라고 알림을 요청
            - 이 클록에서 부터 온 인터럽트가 타임 아웃
        - 실행 상태에 들어가는 프로세스는 CPU의 개수와 같음
        - 타임 슬라이스 동안만 작업 가능하고, 타임 아웃이 발생하면 timeout 명령이 발생, 이 명령어는 프로세스 제어 블록은 실행 상태에서 준비 상태로 옮김
        - 프로세스가 입출력을 요청하면 block 명령어로 대기 상태로 보냄
    4. 완료 상태
        - 실행 상태의 프로세스가 주어진 시간 동안 작업을 마친 상태
        - 프로세스 제어 블록이 사라진 상태
        - 코드와 사용했던 데이터를 메모리에서 삭제, 프로세스 제어 블록을 폐기
        - 비정상 적으로 종료 되었다면, 종료 직전의 메모리 상태를 저장 장치로 옮겨 디버깅 가능하게 해줌 ( core dump 작업 )
    5. 대기 상태
        - 실행 상태에서 프로세스가 입출력을 요구하는 상황을 상정
        - 이는 요리사 모형에서 재료 준비가 안된 상황이랑 유사 → 재료 준비가 되면 알려달라고 하고 작업을 대기 상태로 보냄
        - CPU는 입출력 관리자에게 데이터 입출력을 명령하고, 이 프로세스를 대기 상태로 보냄
        - 즉 대기상태는, 입출력을 요구한 프로세스가 입출력이 완료 될 때까지 기다리는 상태를 칭함
        - CPU 스케줄러는 대기 상태로 프로세스가 이전되면, 준비 상태에 있는 프로세스를 실행 상태로 가져 옴
        - 대기 상태에 있는 프로세스의 입출력 요청이 완료 되었다는 인터럽트를 받으면, 해당 프로세스를 다시 준비 상태로 옮김
        - 입출력 장치 별로 마련된 큐에서 대기함
        - 입출력이 완료 되면, wakeup 명령어로 대기 상태에서 준비 상태로 프로세스 제어 블록을 이동 시킴
- 휴식 상태
    - 프로세스가 작업을 일시적으로 쉬고 있는 상태
    - 종료 된 것이 아니라, 실행을 잠시 멈춘 상태
    - 사용하던 데이터, 제어 블록들이 메모리에 그대로 유지 되어 멈춘 지점부터 재 시작 가능
- 보류 상태
    - 프로세스가 메모리에서 잠시 쫓겨난 상태
    - 일시 정지 상태로도 불림
    - 보류 상태의 예제
        - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보낼 때
        - 프로그램에 오류가 있어 실행을 미루어야 할 때
        - 악의 적인 공격을 하는 프로세스라고 판단 될 때
    - 대부분이 컴퓨터의 성능을 떨어뜨리거나, 실행을 미루어도 큰 지장이 없는 프로세스들
    - 메모리 밖으로 쫓겨나 swap area에 보관 됨
    - 보류 대기 상태
        - 대기 상태에서 옮겨진 보류 상태
        - 재시작 시 대기 상태로 돌아감
        - 이 상태에서 입출력이 완료되면, 보류 준비 상태로 이동 됨
    - 보류 준비 상태
        - 준비 상태에서 옮겨진 보류 상태
        - 재시작 시 준비 상태로 돌아감

## 프로세스 제어 블록과 문맥 교환

### 프로세스 제어 블록

- 프로세스를 실행 하는데 필요한 중요 정보를 보관하는 자료 구조
- 모든 프로세스는 고유의 프로세스 제어 블록을 가지고 있음
- 프로세스 실행 완료 시 폐기
- 프로세스 제어 블록 구성 요소
    1. 포인터
        - 준비 상태, 대기 상태에서는 Queue의 형태로 프로세스 제어 블록이 관리 되는데, 이 Queue를 구현하기 위해 존재
        - 대기 상태에서는 같은 입출력을 기다리는 프로세스 끼리 Queue를 구성 → 각 queue를 Ready queue라고도 부름
    2. 프로세스 상태
        - 프로세스가 현재 어떤 상태 ( 생성 상태, 준비 상태, 실행 상태 ... )에 있는 지에 대한 정보
    3. 프로세스 구분자
        - 여러 프로세스를 구별하기 위한 구분자를 저장 ( ID )
    4. 프로그램 카운터
        - 다음에 실행 될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장
    5. 프로세스 우선순위
        - 준비 상태에서 Queue는 여러 개임
        - 이 때 우선 순위별로 queue가 배정되고, 프로세스 제어 블록이 담긴다
        - 높은 우선순위의 프로세스가 더 자주 실행되고, 먼저 실행된다
    6. 각종 레지스터 정보
        - 프로세스가 실행 되는 중에 사용하던 레지스터에 대한 정보
        - 해당 값을 보관해야 다음에 해당 값부터 실행 가능 하기 때문에 레지스터의 중간값을 저장
    7. 메모리 관리 정보
        - 프로세스의 메모리 위치에 대한 정보, 메모리 보호를 위해 사용하는 경계 레지스터, 한계 레지스터 값 등이 저장
    8. 할당된 자원 정보
        - 프로세스를 위해 사용 되어야 하는 입출력 자원, 파일 등에 대한 정보
        - 접근 해야할 저장 장치, 사운드 카드에 대한 정보가 저장 됨
    9. 계정 정보
        - CPU 할당 시간, CPU 사용 시간 등에 대한 정보
    10. 부모 프로세스 id, 자식 프로세스 id
        - PPID ( Parent PID ), CPID ( Child PID )정보가 저장 됨
- 문맥 교환 ( Context switching )
    - 요리
        - 한가지 요리를 마친 뒤, 주문서를 교환하는 작업이 진행 됨
        - 이때, 주문서 교환 뿐 아니라 이전의 요리를 위해 준비 했던 재료들을 정리 해야 한다.
        - 즉, 주문서를 바꾸는 것과 동시에 환경을 바꾸는 작업
    - 컴퓨터
        - CPU를 차지하던 프로세스가 나가고, 새로운 프로세스를 받아들이는 작업을 칭함
        - 프로세스 제어 블록의 내용이 변경 됨
        - 이전의 프로세스 제어 블록 에는 지금 까지 진행 되었던 작업 내용을 기록 하고, 실행 상태로 들어오는 프로세스 제어 블록의 내용을 CPU에 세팅
        - 위의 일련의 작업을 Context switching ( 문맥 교환 ) 으로 칭함
    - 한 프로세스의 타임아웃이 일어 났을 때, 인터럽트가 발생 했을 때 등의 경우에서도 문맥 교환이 발생 함