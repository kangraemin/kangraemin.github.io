---
title: 운영체제 스터디 (11) - 입출력 시스템과 저장 장치
date: 2021-03-11
categories:
 - Operation System
tags:
 - OS
 - Computer structure
 - Computer science
---

> 운영체제 스터디 도중 [쉽게 배우는 운영체제](http://www.yes24.com/Product/Goods/62054527)를 읽고 요약한 내용입니다. 자세한 내용은 책을 구매하여 확인 부탁드립니다. 

<!-- more -->

# 10. 입출력 시스템과 저장 장치

## 입출력 시스템

### 입출력 장치와 채널

- 컴퓨터의 각 장치는 메인보드에 있는 버스로 연결
- 데이터 전송 속도에 따라 저속 주변장치와 고속 주변장치로 구분
- 저속 주변 장치
    - 메모리와 주변 장치 사이의 데이터 전송량이 적어 데이터 전송률이 낮은 장치
    - 키보드 / 마우스 등이 해당
- 고속 주변 장치
    - 메모리와 주변 장치 사이의 데이터 전송량이 커 데이터 전송률이 높은 장치
    - 그래픽카드 / 하드디스크 등이 해당
- 버스에는 많은 주변 장치가 연결되어 있는데, 버스를 하나만 사용하는 경우엔 병목 현상이 발생 할 수 있음
- 채널
    - 여러 개의 버스를 묶어서 사용하는데, 데이터를 지나다니는 하나의 통로
    - 도로의 차선과 비슷한 개념
    - 4채널 버스는, 4개의 주변 장치가 동시에 데이터를 주고받을 수 있는 4차선 도로와 동일
- 채널의 공유 / 분리
    - 주변 장치는 저마다 데이터 전송 속도가 다름
    - 같은 차선에 느린 데이터 전송 속도를 가진 버스가 있으면, 버스가 막힘
    - 따라서 속도가 비슷한 장치끼리 묶어 채널을 분리하여 사용하는것이 병목 현상을 줄일 수 있음

### 입출력 버스의 구조

- 초기
    - 모든 장치가 하나의 버스로 연결
    - CPU가 작업을 진행하다가, 입출력 명령을 만나면 입출력 장치에서 직접 데이터를 가져 옴 → 풀링 방식
    - 입출력이 끝날 때 까지 다른 작업을 할 수 없음
- 입출력 제어기 사용
    - 주변장치의 입출력을 대행해주는 장치
    - 여러 채널에서 온 데이터를 메모리로 옮기는 역할을 함
    - 모든 입출력을 입출력 제어기에 맡기는 구조로 변경
    - 메인 주방장이 주방 보조를 둔 것과 같은 효과
    - 메인버스 ( 고속으로 작동하는 CPU / 메모리가 사용 ) / 입출력 버스 ( 주변 장치가 사용 )로 나뉨
- 입출력 버스 분리
    - 주변 장치들 사이에서도 속도 차이가 남
    - 고속 주변장치의 데이터 전송이 저속 주변 장치 때문에 느려지는 일이 빈번하게 발생
    - 저속 / 고속 입출력 장치의 버스를 분리하여 운영
    - 채널 선택기
        - 데이터 전송을 저속 / 고속 입출력 채널 에서 데이터를 받는데, 고속에서 10번 받아야 저속 버스에서 1번을 받는 식으로 데이터 받는 속도를 조절
    - 그래픽 카드는 AGB ( Accelerated Graphics Port )라는 그래픽 카드 전용 포트로 관리
    - 메인 버스와 직접 연결된 그래픽 버스를 활용
    - 즉, 컴퓨터에선 메인 버스 / 그래픽 버스 / 고속, 저속 입출력 버스를 사용 중
- 직접 메모리 접근 ( Directrly Memory Access )
    - 메모리는 CPU의 명령에 따라 작동
    - CPU의 도움 없이도 메모리에 접근 할 수 있도록 입출력 제어기에 부여된 권한
    - 메인 메모리에 CPU가 사용하는 공간과는 분리 된 공간인 입출력 메모리에 접근 함
- 링크 : [인터럽트](https://kangraemin.github.io/operation%20system/2020/10/20/interrupt/) 참고

## 디스크 장치

### 디스크 장치의 종류

- 하드디스크
    - 순차적으로 데이터에 접근하는 방식 ( 테이프 드라이브 )이 아닌, 원반을 활용하여 앞 / 뒤에서 접근하는 속도가 비슷해 진 저장 장치
    - 플래터
        - 자성을 활용하여 0, 1의 데이터를 저장하는 곳
        - N극을 띄면 0 / S극을 띄면 1로 인식
        - 보통 2장 이상으로 구성되며, 일정한 속도로 회전되고, 회전 속도를 rpm ( rotation per minute ) 이라고 표기
    - 섹터 / 블록
        - 섹터
            - 하드디스크의 가장 작은 저장 단위
            - 하나의 섹터에는 한 덩어리의 데이터가 저장 됨
        - 블록
            - 하드디스크와 컴퓨터 사이에 데이터를 전송하는 논리적인 저장 단위 중 가장 작은 단위
            - 여러개의 섹터로 구성 됨
            - 클러스터 라고도 표기 됨 ( in window )
            - 운영체제 입장에서는, 하드디스크에 데이터를 보내거나 받을 때 블록이 가장 작은 단위가 됨
    - 트랙 / 실린더
        - 트랙
            - 플래터에서 회전축을 중심으로 데이터가 기록되는 동심원에 있는 섹터의 집합
            - 동일한 동심원상에 있는 섹터의 집합
        - 실린더
            - 여러개의 플래터에 있는 같은 트랙의 집합
    - 헤드
        - 데이터를 하드디스크에 읽거나 쓸 수 있도록 해주는 장치
        - Read / Write 헤드로 구분 되어 있음
        - 데이터가 저장되는 플래터 표면 수와 같은 헤드 수가 있음
        - 플래터가 회전하면, 헤드는 약간 뜬 상태로 유지됨
        - 헤드가 플래터에 붙어버리면, 해당 섹터는 저장을 할 수 없는 구역이 될 수 있는데, 이 구역을 배드 섹터라고 지칭
        - 컴퓨터가 종료 될 때, 헤드를 플래터의 맨 바깥쪽으로 이동시키나, 갑작스런 정전, 코드를 갑자기 뽑았을 때 등 전력이 갑자기 없어지면, 헤드가 이동되지 못해 배드 섹터가 생길 수 있음
- CD
    - 원반을 사용하는 저장 장치 중 하나
    - 트랙 / 섹터로 구성되며, 수평으로 움직이는 헤드가 트랙 사이를 움직이면서 데이터를 읽음
    - 하드디스크는 자성으로 0 / 1을 구분하지만, CD는 원반에 홈을 파고, 헤드에서 발사된 레이저가 홈에 들어가 반사가 되지 않으면 0 / 반사가 되어 돌아오면 1로 구분
    - CD를 굽는다는 표현 자체가, CD에 홈을 내는 것에서 비롯 된 것
- 하드디스크 vs CD
    - 원반을 사용하는건 같지만, 구동 방식이 다름
    - 하드디스크의 경우, 플래터가 일정한 속도로 돌아가지만, CD의 경우 헤드 위치에 따라 디스크의 회전 속도가 변함
    - 하드디스크
        - 일정한 속도로 회전하기 때문에, 바깥쪽 트랙의 속도가 안쪽 트랙의 속도보다 훨씬 빠름
        - 따라서, 가장 바깥쪽에 있는 섹터가 가장 안쪽에 있는 섹터보다 더 큼
        - 조용하며, 구현이 쉬움
        - rpm으로 성능을 측정
    - CD
        - 어느 트랙에서나 단위 시간당 디스크의 이동거리가 같도록 원판의 회전 속도를 조절 함
        - 어느 구간에서나 섹터가 같음
        - 빨라야 할 구간에서는 시끄러우며, 구현이 쉽지 않음
        - 헤드가 올라가있는 위치마다 회전 속도가 다르기 때문에, rpm으로 성능 측정이 불가능
        - 최초의 CD의 속도의 배수로 성능을 표기 ( 20X는, 최초의 CD보다 20배 빠르다는 의미 )

### 디스크 장치의 데이터 전송 시간

- 하드디스크의 경우, 데이터를 전송하는데 걸리는 시간은 아래 처럼 분리 할 수 있음
- 탐색 시간
    - 헤드가 섹터가 있는 트랙까지 이동하는데 걸리는 시간
    - 나머지 소요 시간에 비해 상대적으로 가장 오래 걸림
- 회전 지연 시간
    - 트랙까지 이동 후, 원하는 섹터가 나올 때 까지 플래터를 회전시키는데 소요 된 시간
- 전송 시간
    - 섹터에 있는 데이터를 읽고 전송하는데 소요되는 시간
- 총 데이터 전송 시간 = 탐색시간 + 회전 지연 시간 + 전송 시간
- 탐색시간을 최소화 하는 것이 관건

### 디스크 장치 관리

- 파티션
    - 디스크를 논리적으로 분리하는 작업
    - 파티션 하나에 하나의 파일 시스템이 탑재 됨
    - 일반적으로, C 드라이브 → D 드라이브 → E 드라이브 ... 등 의 이름으로 지정됨
    - C드라이브에는 OS에 관련된 데이터만 설치 할 것을 권고 하고 있음
    - 마운트
        - 하나의 하드디스크는 하나의 파티션으로 분류되는게 일반적
        - 유닉스 운영체제는 여러개의 하드디스크를 하나의 파티션으로 묶을 수 있는 기능을 제공하기도 하는데, 이를 마운트라고 지칭
- 포매팅
    - 디스크를 초기화하는 작업
    - 파일 시스템을 각 파티션의 상단부에 탑재하고, 저장 장치의 모든 섹터를 0으로 만들어 운영체제가 사용 할 수 있도록 준비하는 작업
    - 가상 메모리 시스템에서, 가상 주소를 물리 주소로 변환하기 위해 페이지 테이블을 사용
    - 저장 장치도 마찬가지로, 디스크에 저장된 파일의 위치와 크기 정보를 담고 있는 파일 테이블을 사용
    - 운영체제마다 고유의 파일 테이블이 있음 ( Window → FAT / NTFS ... , Unix → I-node ... )
    - 빠른 포매팅
        - 데이터는 그대로 둔 채 파일 테이블을 초기화 하는 방식
    - 느린 포매팅
        - 모든 섹터를 0으로 만드는 작업
        - 하드디스크를 처음 사용 할 때 주로 사용
        - 배드 섹터를 찾고 싶다면, 느린 포매팅을 해야 함
- 조각 모음
    - 파일을 저장했다, 지웠다를 반복하면 디스크 중간중간 빈공간이 생김
    - 이러한 빈 공간을 없애주는 작업
    - 빈 공간을 없애므로써, 파일 탐색의 속도를 향상시켜 줌

## 디스크 스케줄링

- 하드디스크에서 데이터를 가져 올 때, 탐색 시간이 일반적으로 가장 오래 걸림
- 이떄, 탐색 시간을 줄이고자 헤드를 움직이는 방식을 디스크 스케줄링이라 칭함
- FCFS 디스크 스케줄링
    - 따로 최적화를 위한 스케줄링 방식 없음
    - 그냥 들어 오는데로 헤드를 움직임
    - 가장 오래 걸림
- SSTF 디스크 스케줄링
    - 현재 헤드가 있는 위치에서 가장 가까운 트랙부터 서비스
    - 다음에 서비스할 두 트랙의 거리가 같다면, 먼저 요청받은 트랙을 서비스
    - 가장 멀리 있는 서비스가 아사 현상이 발생 할 수 있음
- 블록 SSTF 디스크 스케줄링
    - 트랙 요청을 블록으로 묶음
    - 블록 내에서 SSTF 디스크 스케줄링 시행
    - 성능은 별로인편
- SCAN 디스크 스케줄링
    - 헤드가 한방향으로만 움직이며 작업을 진행 하도록 스케줄링
    - 한 방향의 끝까지 가면, 반대편 방향으로 가며 계속 트랙을 서비스 함
    - 엘리베이터 기법으로도 불림
    - 많이 사용되는 기법 중 하나이지만, 동일한 트랙이나 실린더 요청이 계속 들어온다면 아사 현상이 발생 할 수 있음
- C-SCAN 디스크 스케줄링
    - SCAN 디스크 스케줄링과는 다르게, 헤드가 한쪽 방향으로 움직일 때는 요청받은 트랙을 서비스 하고, 반대 방향으로 돌아 올 떄는 서비스 하지않고 이동만 함
    - SCAN 방식과 마찬가지로 아사 현상이 발생 할 수 있음
- LOOK 디스크 스케줄링
    - SCAN 방식과는 다르게, 이동하던 방향으로 더이상 서비스 할 트랙이 없으면, 방향을 변경
    - 불필요한 이동이 줄어듬
    - 많이 사용되는 스케줄링
- C-LOOK 디스크 스케줄링
    - C-SCAN의 LOOK 버전

## RAID

- Redundant Array of Independent Disks의 준말
- 자동으로 백업을 하고, 장애가 발생하면 이를 복구하는 시스템을 레이드라 지칭
- 동일한 규격의 디스크를 여러개 모아 구성 하며, 장애가 발생 했을 때 데이터를 복구하는데 사용 됨
- 데이터 저장 방식에 따라 입출력 속도를 향상 시키는 방식도 존재
- RAID 0
    - 병렬로 연결 된 여러개의 디스크에, 데이터를 동시에 입출력 할 수 있도록 구성
    - 데이터 4개를 저장 할 때, 한 디스크에 4개를 저장 하는것이 아니라, 4개의 디스크에 1개씩 저장하여 입출력 속도를 4배 빠르게 함
    - 여러갈래로 데이터를 찢어 저장하는 방식 ( 스트라이핑으로도 부름 )
    - 복구하는 기능이 존재하지 않음
- RAID 1
    - 데이터를 2개의 디스크에 동일하게 저장 ( 미러링 )
    - 백업 디스크를 하나 만들어 놓는 것
    - 하나의 데이터 저장 공간이 망가지면, 다른 디스크에서 데이터를 가져와 복구
    - 같은 크기의 디스크가 최소 2개 이상 필요하며, 짝수개의 디스크로 구성 됨
    - 비용 증가 및 속도가 느려질 수 있음
- RAID 2
    - 오류를 검출하는 기능이 없는 디스크에 대해, 오류 검출 / 교정 코드를 따로 관리하고 오류가 발생하면 이 코드를 활용해 디스크를 복구
    - 일반적인 하드디스크에는, 오류 검출 코드가 없음
    - 오류 교정 코드를 별도의 디스크에 따로 보관하고 있다가, 오류가 발생하면 이를 활용하여 데이터를 복구 할 수 있음
    - 블록 단위로 저장 하는것이 일반적이나, RAID 2에서는 여러개 디스크에 비트 단위로 데이터를 나누어 저장
    - 비트 단위로 저장하면, 각 비트의 오류 교정 코드를 구성하여 나중에 비트단위로 복구하기 위해
    - 오류 교정 코드를 계산하는데 많은 시간이 쓰이고, 디스크도 많이 쓰이기 때문에 잘 사용되지 않음
- RAID 3
    - 패리티 비트를 활용하여 데이터를 복구
    - 4개의 디스크에 데이터를 저장하고, 별도 하나의 디스크에 패리티 비트를 보관했다고 가정
    - 이때, 세번쨰 디스크에 장애가 생겨 복구해야 한다면, 패리티 비트를 기준으로 복구 할 수 있음
    - RAID 2와 같이 데이터를 여러 개의 디스크에 나누어 저장하지만, 비트 단위가 아닌 섹터 단위로 데이터를 나누어 저장
    - 일반적으로 디스크는 섹터 단위로 읽기 때문에, 어떤 세거에 오류가 있는지 없는지 여부를 알 수 있음
    - 오류 검출에 사용하는 패리티 비트를 여러 섹터 끼리 묶어서 구성하면, 오류가 없는 섹터를 활용하여 오류가 있는 섹터의 데이터를 복원 할 수 있음
    - N-way 패리티 비트 방식이라고 부름
    - 디스크 4개당 1개 정도의 추가 디스크가 필요
    - N-way 패리티 비트를 구성하는데 필요한 계산량이 많은것이 단점
    - 데이터를 읽거나 쓸 때, 패리티 비트를 구성하기 위해 모든 디스크가 동시에 동작 해야 함
    - 모든 패리티 비트가 하나의 디스크에 저장 되기 때문에, 입출력이 일어날 때마다 패리티 비트 디스크에 데이터가 저장 되어 병목 현상이 일어날 수 있음
    - 패리티 비트가 저장된 디스크와, 다른 디스크에서 동시에 장애가 발생 할 경우 복구가 불가능
- RAID 4
    - RAID 3와 같은 방식이지만, 처리하는 데이터가 블록 단위
    - 따라서 RAID 3와 다르게, 데이터가 저장되는 디스크와 패리티 비트가 저장되는 디스크만 동작 가능
    - 계산량이 많은 편
    - 디스크 4개당 1개 정도의 추가 디스크가 필요
    - 모든 패리티 비트가 하나의 디스크에 저장 되기 때문에, 입출력이 일어날 때마다 패리티 비트 디스크에 데이터가 저장 되어 병목 현상이 일어날 수 있음
    - 패리티 비트가 저장된 디스크와, 다른 디스크에서 동시에 장애가 발생 할 경우 복구가 불가능
- RAID 5
    - RAID 3 / 4의 병목 현상을 해결하기 위해 RAID 4의 패리티 비트를 여러 디스크에 분산하여 구성
    - 패리티 비트를, 데이터가 보관되지 않은 곳에 보관 → 패리티 비트를 여러 디스크에 저장
    - 패리티 비트를 분산 보관하여 패리티 비트 디스크의 병목 현상 완화
    - 패리티 비트가 담긴 디스크 하나가 장애가 나도, 다른 패리티 비트는 살아 있을 수 있음
    - 디스크 2개가 동시에 장애가 발생 했을 때에는, 해당 데이터에 대해선 복구 불가
- RAID 6
    - RAID 5와 같은 방식이지만, 패리티 비트를 2개로 구성하여 분산
    - 디스크 2개의 장애를 복구 할 수 있음
    - 계산량이 많다는 것, 디스크 4개당 2개의 추가 디스크가 필요하다는 단점이 있음
- RAID 10 / RAID 01
    - 빠른 입출력이 장점인 RAID 0, 복구 기능을 가진 RAID 1을 결합 한 형태
    - RAID 10 → RAID 1 + RAID 0 을, RAID 01 → RAID 0 + RAID 1을 의미
    - RAID 10
        - 4개의 디스크를 2개씩 묶어 RAID 1로 구성하고, RAID 1로 붂인 디스크를 RAID 0으로 다시 묶음
        - 장애가 발생 했을 때, 복구하기 위해 장애가 발생한 부분의 디스크 묶음만 중단 하면 됨 ( 미러링된 디스크가 같은 곳에 묶여 있기 떄문 )
        - RAID 01 보다 많이 사용 됨
    - RAID 01
        - 4개의 디스크를 2개씩 묶어 RAID 0을 구성하고, RAID 0으로 묶인 디스크를 RAID 1로 다시 묶음
        - 장애가 발생 했을 때, 복구하기 위해 모든 디스크를 중단 해야 함 ( 미러링된 디스크가 같은 곳에 묶여 있지 않기 떄문 )
    - 공통
        - 둘 다 병렬로 데이터를 처리하여 입출력 속도를 높일 수 있으며, 미러링된 디스크로 복구가 가능
        - 최소 4개 이상의 디스크가 필요
- RAID 50 / 60
    - RAID를 5 / 6으로 묶고, 묶인 걸 RAID 0으로 묶어 성능을 높이는 방식
    - RAID 10에 비해 추가되는 디스크의 수가 적지만, 입출력 시 계산 량이 증가 ( RAID 5 / 6의 장단점 보유 )
