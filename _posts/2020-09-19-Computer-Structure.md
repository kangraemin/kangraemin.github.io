---
title: 운영체제 스터디 (2) - 컴퓨터의 구조와 성능 향상
date: 2020-09-19
categories:
 - Operation System
tags:
 - OS
 - Computer structure
 - Computer science
---

> 운영체제 스터디 도중 [`쉽게 배우는 운영체제`](http://www.yes24.com/Product/Goods/62054527)를 읽고 요약한 내용입니다. 자세한 내용은 책을 구매하여 확인 부탁드립니다. 

<!-- more -->

# 2. 컴퓨터의 구조와 성능 향상

## 컴퓨터의 기본 구성

1. 하드웨어의 구성
    - 컴퓨터의 대부분의 작업은 중앙 처리장치, 메인 메모리의 협업으로 이루어짐
    - 중앙 처리장치와 메인 메모리는 필수 장치로 분류됨
    - 이외의 부품은 주변장치로 분류 ( 입력장치, 출력장치, 저장장치 ... )
    - 메인 메모리는 전력이 끊기면 데이터를 잃어버린다.
        - 데이터를 영구히 보관하기 위해서는 하드디스크나 USB메모리를 사용해야 한다.
        - 그래서 메인 메모리를 제 1 저장장치, 하드디스크 / USB를 보조 저장장치라고 지칭
    1. CPU와 메모리 
        - CPU는 명령어를 해석하여 실행하는 장치
        - 메모리는 작업에 필요한 프로그램과 데이터를 저장하는 장소
            - 바이트 단위로 분할되어 있음
            - 분할 공간마다 주소로 구분되어 있음
            - 전자의 이동으로 데이터를 처리 ( TODO : 데이터 처리 방식 ? )
    2. 입출력 장치
        - 입력장치
            - 외부의 데이터를 컴퓨터에 입력하는 장치
            - 천공카드, 키보드, 마우스, 터치스크린 등이 해당
        - 출력장치
            - 처리한 결과를 사용자가 원하는 형태로 출력하는 장치
            - 프린터, 모니터, 스피커 등이 해당
    3. 저장장치
        - HDD는 구동장치가 있는 기계이므로 속도가 느림
            - HDD의 저장 원리
                - 외부와 차단된 진공 내부 공간에 데이터가 저장되는 공간인 플래터 가 존재 ( 자기성 원판 )
                - 플래터는 자성체로 코팅 되어 있으며, 자성을 이용하여 0, 1을 기록
                - 하드디스크는 플래터를 읽을 수 있는 헤드, 헤드를 움직이는 access arm, arm을 움직이는 구동장치로 구성되어 있음
                - 헤드가 직접 플래터에 닿는것이 아니라, 매우 낮은 높이 ( 나노미터 단위 )로 떠서 데이터를 읽음
                - 부상하지 않은 채로 플래터가 돌아가면, 하드웨어가 손상된 bad sector가 생길 수 있음
                - 물리적인 충격에 주의해야 함
            - SSD의 저장 원리
                - HDD는 플래터에 암과 헤드를 통해 하드웨어가 직접 데이터를 기록하므로 속도의 한계가 존재 했음
                - SSD는 모든 저장 장치가 플래시 메모리로 구성되어 있다. ( 낸드 플래시로 구성 )
                - 저장 장치에 데이터를 저장하고, 관리하고, 데이터를 읽는 것을 관리하는 컨트롤러가 매우 중요 → 컨트롤러가 저급하다면, 성능이 좋을 수 없음
                - SSD의 캐시 영역을 위해 DRAM도 사용됨 ( DRAM → 휘발성 ! )
                - 플래시 메모리는 셀 당 수명이 존재하기 때문에, 많이 쓰면 데이터 안정성에 영향을 줄 수 있음
        - 저장 용량에 비해 가격이 싸기 때문
        - 전원 온오프와 관계 없이 데이터를 영구적으로 저장
        - 자성을 이용하는 장치, 레이저를 이용하는 장치, 메모리를 이용하는 장치로 구분 됨
    4. 메인보드
        - CPU와 메모리 등 다양한 부품( CPU, 그래픽카드 ... )들을 연결하는 커다란 판
        - 컴퓨터의 부품이 `버스`로 연결됨
        - 버스가 메인보드에 연결된 장치들에 데이터를 전송하는 역할을 함
        - 버스는 각 장치들을 연결하는 선의 집합이자 데이터가 다니는 연결 통로
        - 전력이 공급되면 버스로 연결된 부품이 작동한다
2. 폰노이만 구조
    - CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어 있는 구조를 지칭
    - 하드웨어는 그대로 둔 채 작업을 위한 프로그램만 메모리에 교체하여 메모리에 올리는 방식
    - 모든 프로그램은 메모리에 올라와야 실행 할 수 있다는 전제
    - 운영체제도 프로그램 이기 때문에 메모리에 올라와야 실행이 가능함
3. 요리사 모형
    - 메인 요리사 → CPU / 보관 창고 ( 저장장치 ) / 도마 ( 메모리 ) / 주방 보조 ( 보관 창고에 있는 재료를 도마로 옮겨주는 역할 ) / 채소를 다듬거나, 고기를 손질하는 보조 요리사 로 요리하는 공간 상정
    - 메인 요리사 ( CPU )가 요리를 하려면 보관 창고 ( 저장 장치 )에 있는 재료를 도마 ( 메모리 )에 올려야 가능
    - 요리 방법 결정 → CPU의 프로세스 관리
    - 도마 위의 재료를 정리 → 여러 프로그램이 사용하는 메모리를 관리
    - 보관 창고의 재료를 정리 → 저장 장치 내의 데이터를 관리 하는 것에 비유
    - 도마가 너무 작아 도마에 손질 할 재료를 한번에 올릴 수 없어 저장장치에서 매번 가져와야 한다면 요리사가 요리하는데 속도를 내지 못할 것 → 도마가 손질할 재료를 올리기에 충분히 크다면 요리사가 요리하는데 충분한 속도를 낼 수 있음
        - 모든 조건이 동일 할 때, 응용 프로그램이 1GB보다 더 큰 메모리를 요구한다면, 1GB램이 장착되어 있는 컴퓨터 보다 4GB램이 장착되어 있는 컴퓨터의 속도가 더 빠를 것
    - 하지만 손질할 재료를 다 올리고도 도마를 더 키운다고 해서 요리 속도가 빨라지진 않음
        - 메모리가 16GB면 충분한 작업을 하는 경우에, 메모리가 32GB가 되었다고 해서 두배 더 빨라지는것이 아님
4. 하드웨어 사양 관련 용어
    1. 클록 
        - CPU에서 나오는 박자의 단위
        - CPU에서 박자를 만들어 내면 ( 통칭, tick, pulse, clock tick ) 틱에 맞추어 CPU안의 구성 부품이 작업을 진행
    2. 헤르츠
        - 1초에 클록틱이 몇 번 발생하는지를 나타내는 단위 ( 클록틱이 발생하는 속도를 나타내는 단위 )
        - 1초에 클록틱이 1번이면 1Hz
        - 3.4GHz 는 1초에 34억번 클록틱이 발생하는 것 → 1초에 34억번의 연산을 할 수 있다는 것
        - 메인보드의 버스도 클록틱에 맞춰서 데이터를 전송하기 때문에 메인보드의 성능도 클록으로 표시함
    3. 시스템 버스와 CPU 내부 버스 
        1. 시스템 버스
            - 메모리와 주변 장치를 연결하는 버스 ( Front-Side Bus, 전면버스 )
            - 메인보드의 속도가 1.3GHz인데, 메모리의 속도가 800MHz라면, 메인보드가 800MHz로 작동하여 성능을 다하지 못함
        2. CPU 내부 버스 
            - CPU 내부에 있는 장치를 연결하는 버스 ( Back-Side Bus, 후면버스 )
            - CPU 내부 버스의 속도는 CPU의 클록과 같다.
        - CPU는 CPU 내부 버스의 속도와 시스템 버스의 속도 차이 때문에 작업이 지연되는 문제점이 존재

## CPU와 메모리

1. CPU의 구성과 동작 
    - CPU
        - 명령어를 해석하여 실행하는 장치
        - 요리모형에서의 요리사
        - 연산장치 ( 직접 요리 하는 부분 ) / 제어 장치 ( 작업 지시 ) / 레지스터 ( 재료 임시 보관 장소 )로 구성되어 있음
        1. 산술 논리 연산장치
            - CPU에서 데이터를 연산하는 장치
            - 산술연산 ( 사칙연산 ) / 논리연산 ( AND / OR ) 연산 수행
        2. 제어장치
            - 도마 위의 재료를 가져와라, 양파 껍질을 벗겨놓아라 등의 작업 지시를 진행하는 장치
            - CPU에서 작업을 지시하는 장치
        3. 레지스터
            - 요리할 재료를 필요한 만큼 담아놓은 곳에 해당
            - CPU내에 데이터를 임시로 보관하는 저장소
    - CPU의 명령어 처리 과정

        ```c
        int D2 = 3;
        int D3 = 3;
        int sum = D2 + D3;
        ```

        - D2, D3, sum은 메모리 주소값의 별명 ( 메모리 주소값을 일일이 기억할 순 없으므로 )

        ```wasm
        LOAD mem(100), register 2;
        LOAD mem(120), register 3;
        ADD register 5, register 2, register 3;
        MOVE register 5, mem(160)
        ```

        - 위의 C 코드를 어셈블리어로 변환한 형태
            - CPU는 0과 1로 이루어진 기계어만 인식함
            - 이 기계어를 사람은 이해하기 힘듦 → 기계어와 사람이 이해하기 쉬운 기호를 1대 1대응을 시켜놓은 언어
        - D2는 메모리의 100, D3는 120, sum은 160번지를 가리킨다고 가정
        - register N 은 레지스터 N을 뜻하고, LOAD는 가져오기, ADD는 더하기, MOVE는 옮기는 명령어
        - 따라서 위의 코드를 해석하면
            1. 메모리의 100번지 ( D2 )에 있는 값을 레지스터 2로 가져온다.
            2. 메모리의 120번지 ( D3 )에 있는 값을 레지스터 3으로 가져온다. 
            3. 레지스터 2에 있는 값과, 3에 있는 값을 더해서 레지스터 5에 넣는다. 
            4. 레지스터 5에 있는 값을 160번지 메모리에 옮긴다. 

            가 된다.

        - CPU가 연산을 하기위해 필요한 데이터를 CPU로 가져와야 하는데, 가져오는 장소가 레지스터
        - 3번의 더하기 연산은 산술논리 연산장치에서 진행한다.
        - 제어장치는 명령어를 해석하여 제어 신호를 보내고, CPU내의 흐름을 제어한다.
            - 메모리를 가져와라, 덧셈을 실행하라, 결과값을 옮겨놓아라 등의 신호를 보낸다.
    - 레지스터의 종류
        - 가시 레지스터 : 사용자 프로그램에 의해 변경되는 레지스터
            - 데이터 레지스터
                - 메모리에서 가져온 데이터를 임시로 보관할 때 사용
                - CPU에 있는 대부분의 레지스터가 데이터 레지스터 → 범용 레지스터 / 일반 레지스터 라고 불림
            - 주소 레지스터
                - 메모리 주소값이 저장되는 레지스터
                - 데이터 / 명령어의 메모리 주소값이 저장된다.
        - 특수 레지스터 : 사용자 프로그램에 의해 변경 될 수 없는 레지스터 ( 불가시 레지스터 )
            - 프로그램 카운터
                - 다음에 실행할 명령어의 주소를 기억하고 있다가 제어장치에 알려주는 역할
                    - ex) 1번째 줄에 있는 명령어가 실행 된 뒤엔 2번째 줄이 실행되어야 한다면, 2번쨰 줄 명령어의 주소값을 가지고 있음
                - 다음에 실행할 명령어의 주소값을 가르키기 때문에 명령어 포인터로도 칭함
            - 명령어 레지스터
                - 현재 실행중인 명령어를 저장
                - 제어장치가 명령어 레지스터에 있는 명령을 해석 한 후 외부장치에 적절한 제어 신호를 보낸다.
            - 메모리 주소 레지스터
                - 메모리에서 CPU로 데이터를 가져오거나, CPU에서 메모리로 데이터를 내보낼 때 메모리의 주소를 지정하기 위해 사용
                - 명령어 처리 과정에서 필요한 메모리의 주소를 이 레지스터에 넣으면, 메모리 관리자가 인식해서 메모리 위치의 데이터를 가져오거나, 해당 메모리 위치에 데이터를 저장한다.
            - 메모리 버퍼 레지스터
                - 메모리에서 가져온 데이터나, 메모리로 보낼 데이터를 임시로 저장할 때 사용
                - 메모리 주소 레지스터와 항상 함께 사용 됨
        - 위 어셈블리 코드의 첫번째 줄 해석
            1. 프로그램 카운터 → 현재 실행중인 코드의 행 번호 1이 저장되고, 이 번호가 제어장치로 전송 
            2. 명령어 레지스터에 `LOAD`가 탑제 
            3. 제어장치가 `LOAD`를 해석하여 메모리 있는 데이터를 가져오라고 제어신호를 보냄
            4. 메모리 주소 레지스터에 데이터를 가져올 메모리 주소값인 100이 저장됨 
            5. 메모리 관리자가 메모리 주소 레지스터에 있는 값인 100에 해당하는 메모리 주소에 저장된 값을 메모리 버퍼 레지스터로 가져옴 
            6. 제어 장치는 메모리 버퍼 레지스터에 있는 값을 레지스터 2로 옮김
        - 상태 레지스터
            - 연산 결과가 양수인지, 음수인지, 0이 아닌지, 자리 올림 유무 등을 저장하는데 사용
            - 산술 논리 연산장치와 연결되어 있음
            - 플래그 레지스터, 상태 레지스터, 컨디션 레지스터라고도 불림

            ```c
            if (D2 - D3 > 0)
            	goto 100;
            else
            	goto 200;
            ```

            - 위 코드에서 상태레지스터는 D2-D3의 결과값을 임시로 저장하고 있다가, 음수인지 양수인지 알려주어 다음에 몇번 행으로 이동 할지를 결정
    - 버스의 종류
        - 버스는 CPU와 메모리, 주변 장치들 간에 데이터를 주고 받을 때 사용
        - 제어버스 ( 다음 작업을 지시하는 제어 신호를 전달 ), 주소버스 ( 메모리의 위치 정보를 전달 ),  데이터 버스 ( 처리할 실질적인 데이터 전달 )
        - 제어버스
            - 다음에 어떤 작업을 할 지 지시하는 제어신호가 오고 가는 버스
            - ex) 메모리에서 데이터를 가져와라, 처리할 데이터를 옮겨와라, 저장해라, 사운드 카드에 소리를 내라, 메모리에서 오류가 발생했다 처리해라 ...
            - CPU에서는 제어장치와 제어버스가 연결되어 있음
            - 제어버스는 메모리 / 주변장치 / CPU의 제어장치와 양방향 연결되어 있음
        - 주소 버스
            - CPU에서는 메모리 / 하드디스크( 주변 장치 )의 데이터를 읽거나 쓸 때 작업할 메모리 / 하드디스크 ( 주변 장치 )의 주소값이 담겨있는 정보를 내보내는 버스
            - CPU에서는 메모리 주소 레지스터와 연결 되어 있음
            - 주소 버스는 단방향이며, CPU에서는 정보를 내보내기만 하고 하드디스크 ( 주변장치 )와 메모리에서는 정보를 받기만함
        - 데이터 버스
            - 실제 데이터를 주고 받을 때 사용되는 버스
            - CPU의 메모리 버퍼 레지스터와 연결 되어 있으며 양방향으로 버스가 출입함
    - 버스의 대역폭
        - 한번에 전달 할 수 있는 데이터의 최대 크기
        - CPU가 한번에 처리 할 수 있는 데이터의 크기와 같음
        - 32Bit CPU의 경우엔 한번에 처리 할 수 있는 데이터의 크기는 32Bit, 이 경우 레지스터의 크기도 32Bit, 버스의 대역폭도 32Bit ( 버스의 대역폭과, 레지스터의 크기와, 한번에 처리 할 수 있는 데이터의 최대 크기는 항상 같다 )
        - 위의 경우엔 CPU에서 메모리의 데이터를 읽거나, 쓸 때 한번에 최대 32Bit를 처리 할 수 있다는 뜻
        - CPU가 한번에 처리할 수 있는 데이터의 최대 크기는 워드로 칭하며, 위의 경우에서 1워드는 32Bit 이다.
2. 메모리의 종류와 부팅 
    - 메모리를 이루는 소자 하나의 크기는 1bit ( 0 / 1 만 저장 가능 )
    - 소자 하나로 데이터를 표현 할 수 없기 때문에 1 Byte ( 8 bit ) 단위로 메모리 주소를 지정  ( TODO : 메모리 주소 형태 )
    - 메모리에서 데이터를 읽거나 쓸때는 워드 단위로 움직임
    - 메모리는 크게 램 ( 무작위로 데이터를 읽어도 저장된 위치와 관계 없이 같은 속도로 데이터를 읽을 수 있는 , Random Access Memory ) / 롬 ( 데이터를 읽기만 할 수 있는, Read Only Memory )으로 구분 가능
    - 메모리의 종류
        - 램
            - 휘발성 메모리
                - 전력이 끊기면 데이터가 사라지는 메모리
                - DRAM ( Dynamic RAM )
                    - 저장된 0, 1의 데이터가 일정 시간이 지나면 사라짐 → 일정 시간마다 재생이 필요함
                    - Dynamic : 시간이 지나면 데이터가 사라지기 때문에 재생이 필요함의 의미
                - SRAM ( Static RAM )
                    - 전력이 공급 되는 동안에는 데이터를 보관 할 수 있음 → 재생이 따로 필요없음
                    - 재생이 필요 없기 때문에 속도가 빠르지만, 비싸기 때문에 캐시 같은 고속메모리에는 SRAM 사용 ( TODO : 캐시 ? )
                - SDRAM ( Synchronous Dynamic RAM )
                    - DRAM의 발전된 형태
                    - 클록틱 ( 펄스 )가 발생 할 때 마다 데이터를 저장하는 동기적 DRAM ( TODO : 동기적 ? )
                - RAM을 비휘발성으로 만들면, 전력이 끊겨도 데이터를 보관해야 하기 때문에 메모리 내부가 복잡하고, 속도가 느리며 가격이 비싸다
                - TODO : 그럼 휘발성이면 왜 속도가 빠르고 단순한가 ?
                - DDRSDRM
                    - 클록틱 한번에 2^N개의 워드를 저장
                    - 대역폭을 2^N배 늘릴 수 있음
                    - DDR4 SDRAM이 많이 쓰이고 있음 ( 16배 )
            - 비휘발성 메모리
                - 전력이 끊겨도 데이터가 사라지지 않는 메모리
                - 플래시 메모리
                    - USB드라이버, 디카 따위의 저장장치로 많이 씀
                    - 많이 쓰면 데이터를 잃어버리거나, 성능이 저하될 수 있으니 버려야함
        - 롬
            - 전력이 끊겨도 데이터를 보관
            - 데이터를 한번 저장하면 바꿀 수 없다. ( CD-ROM을 생각, 한번 쓴 CD는 다시 구울 수 없다 )
            - BIOS 를 롬에 저장 ( TODO : BIOS ? )
    - 메모리 보호
        - 현대의 운영체제는 시분할 기법을 활용하기 때문에, 메모리 내 사용자 영역이 여러개의 작업 공간으로 나누어짐
        - 이 경우 반드시 어떤 작업이 다른 작업의 메모리 영역을 침범하지 않도록 해야함
        - 위의 경우처럼 다른 작업의 메모리 영역을 침범하는 악성 프로그램을 바이러스로 지칭
        - 운영체제도 프로그램이기 때문에, 메모리에 운영체제가 올라 가 있는데, 이 부분을 보호해야 함
        - CPU는 현재 진행 중인 작업의 메모리 시작 주소를 경계 레지스터 에 저장하고, 또 현재 진행 중인 작업의 마지막 주소 까지의 차이( 즉, 현재 진행중인 작업이 차지하고 있는 메모리의 크기 ) 를 한계 레지스터 에 저장
        - 사용자의 작업이 진행 되는 동안 작업에 쓰이는 메모리 주소값이 이 작업 범위를 벗어나는지 하드웨어 적으로 벗어나는지를 체크하여 메모리를 보호함
        - 벗어난다면 메모리 오류를 발생시키고, 작업을 바로 강제 종료 시킴
    - 부팅
        - 응용 프로그램 → 운영체제가 메모리에 올리며 실행
        - 운영체제는 누가 올리나
        - 컴퓨터를 켰을 때 운영체제를 메모리에 올리는 과정을 부팅으로 지칭
        - 부팅 과정
            1. 사용자가 전원을 킴
            2. 롬에 저장된 BIOS가 실행
            3. BIOS가 CPU / 메모리 / 하드디스크 / 키보드 등 주요 하드웨어가 제대로 동작하는지 확인 
            4. 3번의 과정 중 문제가 있으면, 삐 ~ 소리와 함께 오류 메세지 출력
            5. 이상이 없으면 하드디스크 ( 저장장치 )에서 마스터 부트 레코드에 저장된 프로그램을 메모리로 가져와 실행 
                - 마스터 부트 레코드 : 하드웨어의 첫 번째 섹터
                - 운영체제를 싱행하기 위한 프로그램인 부트스트랩이 이곳에 저장됨
                - 유닉스용 부트스트랩이 실행되면, 유닉스 운영체제가 메모리에, 윈도우 부트스트랩이면 윈도우 운영체제가 메모리에 올라온다.
                - 하드디스크가 아닌 USB등 이동 저장장치에도 마스터 부트 레코드를 탑재 할 수 있음
                - 부트스트랩 코드를 마스터 부트 레코드에 설치하면 됨
            6. 하드디스크 ( 저장장치 )에 저장된 운영체제를 메모리로 불러옴
        - 따라서 마스터 부트 레코드가 손상되면 운영체제를 실행 할 수 없다.
            - 사용자 옵션 부분에 운영체제 보호 항목을 만들어 이 부분을 수정 못하도록 함

## 컴퓨터 성능 향상 기술

1. 버퍼
    - 일정량의 데이터를 모아 한꺼번에 전송하여  두 장치의 속도 차이를 완화해주는 역할
    - 적은 노력으로 많은 양의 데이터 옮기기 가능
    - 일반적으로 버퍼 사이즈가 큰 것이 속도가 더 빠름
    - 동영상 스트리밍에서도 서비스에서도 재생 되는 도중에 영상이 끊기는 것을 줄이기 위해 버퍼 개념 사용
    - 스풀
        - CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼
        - ex) 프린터의 스풀러
            - 프린터의 스풀러 : 인쇄할 내용을 순차적으로 출력하는 소프트웨어
            - 출력 명령을 내린 프로그램과 독립적으로 동작
            - 인쇄할 내용들을 모두 cpu에서 준비 해준 뒤 하드디스크의 스풀러에 저장
        - 버퍼의 경우 어떤 프로그램이 사용하는 데이터든 버퍼가 가득차면 데이터 전송이 시작됨
        - 스풀러는 다른 프로그램들이 끼어들 수 없음 ( 인쇄에 잡음 생김 )
    - 하드웨어 안전하게 제거하기
        - 데이터를 옮기거나, 가져 올 때 버퍼에 데이터가 가득 차면 데이터 전송이 시작된다.
        - 이때 USB에 데이터를 옮기거나, 가져오는 도중에 USB를 확 뽑아버리면 버퍼에서 데이터들이 전송이 완료되지 않은 채로 뽑힐 수 있다. ( 데이터 유실 )
        - 하드웨어 안전하게 제거하기 기능은 버퍼에 있는, 아직 옮겨지지 않은 데이터들을 USB등의 저장장치로 보내고, USB전원을 차단하기 때문에 안전하게 제거할 수 있도록 해줌
2. 캐시
    - 캐시란 ?
        - 메모리와 CPU간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 저장 장소
        - 버퍼의 일종 ( 데이터를 모아 한번에 전송 )
        - CPU가 사용 할 것으로 예상되는 데이터들을 미리 메모리에서 가져다 놓음 ( prefetch )
        - 장독대 ( 메모리 )의 간장을 간장 통 ( 캐시 )에 담아놓는것 의 비유
        - 캐시는 CPU내부에 있어 CPU 내부 버스의 속도로 동작
        - 캐시 히트 : 필요한 데이터가 캐시 영역에 존재 하는 경우
        - 캐시 미스 : 필요한 데이터가 캐시 영역에 존재 하지 않는 경우
        - 캐시 적중률 : 캐시 히트가 되는 비율 ( 일반적으로 90 % )
        - 캐시 적중률이 높으면 좋은 CPU → 캐시의 크기를 늘리는 것이 적중률 높이는 방법 중 하나 ( 비싸짐 )
        - 지역성 이론 → 현재 위치에 가까운 데이터가 멀리 있는 데이터보다 사용 확률이 높다는 이론 ( 10 번째 행이 실행되고 있을때 101번쨰 행보다는, 11 ~ 20행의 데이터를 가져옴 )
    - 즉시 쓰기와 지연 쓰기
        - 캐시에 있는 데이터가 변경 되는 경우 이를 메모리에 반영 해주어야 함
        - 즉시 쓰기
            - 캐시에 있는 데이터가 변경되면, 즉시 메모리에 반영하는 방식
            - 성능이 느려지지만, 메모리의 값이 항상 최신값이기 때문에 데이터 손실 없음
        - 지연 쓰기
            - 캐시에 있는 데이터가 변경되면, 변경된 내용을 모아서 주기적으로 반영하는 방식 ( copy-back 으로도 칭함 )
            - 성능이 향상되지만, 메모리와 캐시의 값이 일치 하지 않을 수 있음
        - L1 캐시와 L2 캐시
            - 명령어 = 어떤 작업을 할지 나타내는 명령어 + 작업 대상인 데이터
            - 일반 캐시 → 명령어와 데이터를 구분 없이 가져 옴
            - 특수 캐시 → 명령어와 데이터를 구분 하여 가져 옴
            - 명령어 캐시 ( 특수캐시 ) → 명령어 레지스터와 연결  데이터 캐시 → 데이터 레지스터와 연결 ( L1 )
            - 일반 캐시 → 메모리와 연결 ( L2 )
        - 웹브라우저 캐시도 CPU 캐시의 소프트웨어적인 사용법
            - 웹브라우저 캐시 : 다시 방문할 것을 예상하여 지우지 않은 데이터
            - 사이트 재방문시 캐싱된 데이터 사용
3. 저장장치의 계층 구조 
    - CPU ( 속도가 빠른 )에 가까운 쪽에 레지스터 / 캐시를 배치 ( 속도가 빠른 하드웨어 )
    - 앞에서 이야기한 데이터 동기화 문제가 존재
4. 인터럽트
    - 초기의 CPU ( polling 방식 )
        - 초기의 CPU는 CPU가 직접 입출력 장치에서 데이터를 가져오거나 내보냈음
        - CPU가 직접 입출력 장치의 상태를 관리해야 했기 때문에, 주기적으로 입출력 장치의 상태를 확인하고, 이상이 있을시 cpu가 상태 확인 시 처리 해 줌
        - 요리사가 직접 보관 창고에 왔다갔다 하는것과 같음
        - 이때 CPU가 입출력 장치의 상태를 주기적으로 점검하고, 일정한 조건을 만족 할 때 데이터를 처리함
        - 입출력 장치를 검사하는 등의 여러 작업이 추가되므로 효율이 저하
    - 오늘날의 CPU
        - 매우 많은 입출력 장치 → 폴링 방식의 비효율성 극대화
        - 위 방식을 해결하기 위해 인터럽트 방식 도입
    - 인터럽트 방식
        - CPU에 입출력 장치로 부터 신호가 오면 그를 처리해주는 방식
        - CPU가 직접 입출력 장치를 관리하는 폴링 방식 과는 다른 방식
        - 요리사 모형 에서의 인터럽트
            1. 요리사 옆에 주방 보조를 두고 요리사가 계속 요리하는 형태 
            2. 주방 보조에게 재료를 가져오라 명령
            3. 주방 보조가 다 가져오면 준비가 완료 되었다고 알려줌
        - CPU에서의 인터럽트
            1. CPU가 입출력 관리자에게 입출력 명령을 보냄 
            2. 입출력 관리자는 CPU로 부터 받은 입출력 명령을 시행
            3. 데이터 입출력이 완료되면, 입출력 관리자는 완료 신호를 CPU에게 보냄
        - 이때, 입출력 관리자가 CPU에게 보내는 완료 신호를 인터럽트 라고 칭함
        - CPU는 입출력 관리자에게 작업 지시를 내리고, 다른 작업 도중에 데이터 입출력 완료 신호 ( 인터럽트 )가 발생하면, 하던 일을 중단하고 입출력 된 데이터를 처리
        - 하던 작업을 중단하기 때문에 인터럽트라고 불림
        - 주변 장치는 마우스, 키보드, USB등 여러 장치가 있는데, 이 장치들을 구분하기 위해 인터럽트 번호 를 사용
        - 인터럽트 번호 → 주변 장치의 이름 대신에 사용하는 고유번호 ( 운영체제 마다 상이함 )
        - CPU는 입출력 장치에 동시에 여러 작업을 시키는데, 이 때 인터럽트가 동시에 발생한다면 그 때 마다 인터럽트를 발생시켜야 하기 때문에 인터럽트들을 배열화 시킨 인터럽트 배열을 사용
    - 직접 메모리 접근
        - 폴링 방식에서는 CPU가 메모리나 주변장치에 대한 모든 권한을 가지고 있었음
        - 인터럽트 방식으로 넘어오며, 입출력 관리자가 데이터의 입출력을 맡아야 함
        - 하지만 메모리는 CPU만 접근할 수 있는 권한을 가진 공간 → 입출력 관리자가 접근 할 수 없음
        - CPU의 허가 없이 메모리에 접근 할 수 있는 권한이 입출력 관리자에게 필요 함 → 이러한 권한을 직접 메모리 접근 이라고 함
    - 메모리 매핑 입출력
        - 메모리의 일정 공간을 입출력 장치에 할당하는 기법 ( 작업 영역을 나눔 )
            - 직접 메모리 접근 방식이 필수적이지만, 이를 사용하면, 메모리가 복잡해짐
            - 메모리에는 CPU가 사용하는 데이터와, 입출력 장치가 사용하는 데이터가 혼재 되어 있음
            - 이 때, 입출력 장치에서 직접 메모리 접근 방식을 통해 가져온 데이터가 메모리에 따로 정리되어 있지 않다면, CPU가 사용하는 데이터와 섞여서 관리하기 어렵기 때문에 메모리 영역을 나눔
    - 사이클 훔치기
        - 직접 메모리 접근에 CPU의 순서가 밀리는 현상
            - 메모리에 CPU와 입출력 장치가 동시에 접근 할 수 있음
            - CPU, 입출력 장치 중 누군가는 양보해야하는데, CPU가 일반적으로 입출력 장치보다 더 빠르므로 입출력장치, 즉 직접 메모리 접근에 양보 → 사이클 훔치기 현상 발생

## 병렬 처리

- CPU의 속도를 올리고자 하나, 하드웨어 적인 한계 ( CPU 클록을 높이는 것의 한계 )가 있고 이를 해결하기 위해 만든 방법
- CPU의 코어를 여러 개 만들거나, 동시에 실행 가능한 명령의 개수를 늘리는 방법을 사용
1. 병렬 처리 ?
    - 동시에 여러 개의 명령을 처리하여 작업의 능률을 올리는 방식
    - 하나의 코어만 존재하는 CPU에서도 병렬처리 가능
        - 하나의 코어에서 동시에 진행 할 수 있는 작업을 동시에 진행하는 방식으로 진행
            - 요리의 경우, 요리사 한명이 하나의 주방 에서 ( 하나의 코어 ) 재료 세척을 하며, 재료 손질을 하며, 음식을 조리하는 것 ( 두개 이상의 요리를 동시에 조리 : 여러 개의 스레드 활용 )도 가능
        - 하나의 코어에서, 여러개의 스레드를 활용하여 진행 → 파이프 라인 기법
        - 여러개의 스레드를 동시에 처리하는 방법을 CPU 멀티스레드 로 지칭
    - 두개 이상의 코어
        - 두개의 코어가 존재하는 경우, 한 주방에  2개의 독립적인 조리시설이 있는것과 같음
        - 슈퍼 스칼라 기법으로 지칭
        - 듀얼 코어의 경우 코어가 2개 있고, 슈퍼 스칼라 기법을 활용하여 2개 작업을 동시에 처리 가능
2. 병렬 처리 시 고려 사항
    - 상호 의존성이 없어야 병렬 처리가 가능
        - 각 명령이 서로 독립적이며, 앞의 결과가 뒤의 명령에 영향을 미치지 않아야 함
        - 채소 손질이 끝나지 않은 채소를 손질하며 볶는건 불가능함
        - 앞 뒤 단계간의 상호 의존적인 명령어를 사용하면 병렬 처리 불가능
    - 각 단계의 시간을 일정하게 맞춰야 효율적
        - 작업시간이 긴 작업에 bottle neck 발생
    - 전체 작업 시간을 몇 단계로 나눌 지 잘 따져야 함
        - 동시에 처리 할 수 있는 작업의 최대 갯수
        - 병렬 처리의 깊이 → 병렬 처리에서 하나의 작업을 N개로 쪼갰을 때, 깊이는 N이다
        - 너무 깊은 깊이는 새로운 작업을 불러오는데 시간이 많이 걸려 오히려 비효율적
        - 일반적으로 10 ~ 20을 잡음
3. 병렬 처리 기법 
    - CPU 데이터 처리 과정
        - CPU 내에서 명령어는 제어장치가 처리 ( 명령어 가져와 해석 후 데이터 처리 )
        - 이러한 과정 전체를 하나의 스레드 로 지칭
        - 스레드를 이루는 각 단계는 CPU의 클록틱 한번에 하나씩 이루어짐
            1. 명령어 패치 : 다음에 실행할 명령어를 명령어 레지스터에 저장 
            2. 명령어 해석 : 1에서 저장한 명령어를 해석
            3. 명령어 실행 : 2에서 해석한 명령어를 실행
            4. 쓰기 : 3에서 실행된 결과를 메모리에 저장 
    - 파이프 라인 기법
        - 명령을 겹쳐서 실행하는 방법
        - 하나의 코어에서 여러 개의 스레드를 사용하는 것
            1. 명령어를 여러 개의 단계로 분할
            2. 각 단계를 동시에 처리하는 하드웨어를 독립적으로 구성
        - 파이프 라인의 위험
            - 데이터 위험
                - 데이터의 의존성 때문에 발생하는 문제
                - 2번째 명령어가 첫번째 명령어에 의존되어 있다면, 첫번째 명령어와 두번째 명령어는 동시 실행 불가
                - 명령어 단계를 지연 ( stall ) 하여 해결 / 포워딩을 활용하여 해결 ( 실행 ( EX ) 된 데이터를, 저장 하기 전 다음 단계로 내보내줌 )
            - 제어 위험
                - 첫번째 명령문을 실행하며 두번쨰 명령문을 실행 하고 있는데, 첫번째 명령문을 실행하고 보니 goto 문이나, if문의 발생으로 두번째 명령문이 아닌 다른 명령문을 수행하는 것이 옳은 경우에 두번째 명령문에서 이미 실행한 명령어들이 쓸모가 없어지는 위험
                - 분기 예측 / 분기 지연 방법 ( 첫번째 명령어가 끝날 때 까지 두번째 명령을 stall 시키는 방법 )
            - 구조 위험
                - 서로 다른 명령어가 같은 자원에 접근하려 할 때 발생하는 문제
                - 첫번째 명령어가 레지스터 RX를 사용하고 있는데, 두번째 명령어도 레지스터 RX를 사용해야 한다면 서로 충돌하여 생기는 위험
                - 해결하기 어려움
    - 슈퍼 스칼라 기법
        - 파이프 라인을 처리할 수 있는 여러 개의 코어를 구성 → 복수의 명령어 동시 실행
        - 처리되는 명렁어가 상호 의존성 없이 독립적 이어야 함
    - 슈퍼 파이프라인 기법
        - 파이프 라인 기법을 강화한 형태
        - 파이프 라인 기법에서는, 한 클록마다 하나의 명령어를 실행
        - 슈퍼 파이프 라인 기법에서는, 파이프 라인의 각 단계를 세분하여 한 클록 내에 여러 명령어를 처리 할 수 있음
        - 한 클록 내에 여러 명령어 실행시 다음 명령어가 빠르게 실행되어 처리 능력 상승
    - 슈퍼 파이프라인 슈퍼 스칼라 기법
        - 슈퍼 파이프라인 기법에 슈퍼 스칼라 기법을 더한 기법
        - 슈퍼 파이프라인 기법을 여러개의 코어에서 동시에 수행하는 방식
    - VLIW 기법
        - CPU가 병렬처리를 지원하지 않을 시 소프트웨어 적으로 병렬처리를 하는 방법
        - 동시에 수행할 수 있는 명령어들을 컴파일러가 추출 후 하나의 명령어로 압축하여 실행
        - 동시에 처리하는 명령어 개수 적음
        - 앞의 방법에선 명령어 실행 시 병렬 처리가 이루어 지지만 컴파일 시에 병렬 처리가 이루어짐